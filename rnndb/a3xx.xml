<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">
<import file="freedreno_copyright.xml"/>
<import file="adreno_common.xml"/>
<import file="adreno_pm4.xml"/>

<enum name="a3xx_render_mode">
	<value name="RB_RENDERING_PASS" value="0"/>
	<value name="RB_RESOLVE_PASS" value="2"/>
</enum>

<enum name="a3xx_tile_mode">
	<value name="LINEAR" value="0"/>
	<value name="TILE_32X32" value="2"/>
</enum>

<enum name="a3xx_color_format">
	<value name="RB_R8G8B8A8_UNORM" value="8"/>
</enum>

<enum name="a3xx_threadmode">
	<value value="0" name="MULTI"/>
</enum>

<enum name="a3xx_instrbuffermode">
	<value value="1" name="BUFFER"/>
</enum>

<enum name="a3xx_threadsize">
	<value value="0" name="TWO_QUADS"/>
	<value value="1" name="FOUR_QUADS"/>
</enum>

<enum name="a3xx_state_block_id">
	<value name="HLSQ_BLOCK_ID_TP_TEX" value="2"/>
	<value name="HLSQ_BLOCK_ID_TP_MIPMAP" value="3"/>
	<value name="HLSQ_BLOCK_ID_SP_VS" value="4"/>
	<value name="HLSQ_BLOCK_ID_SP_FS" value="6"/>
</enum>

<enum name="a3xx_cache_opcode">
	<value name="INVALIDATE" value="1"/>
</enum>

<enum name="a3xx_fmt">
	<value name="FMT_FLOAT_32" value="0x0"/>
	<value name="FMT_FLOAT_32_32" value="0x1"/>
	<value name="FMT_FLOAT_32_32_32" value="0x2"/>
	<value name="FMT_FLOAT_32_32_32_32" value="0x3"/>

	<value name="FMT_FIXED_32" value="0x8"/>
	<value name="FMT_FIXED_32_32" value="0x9"/>
	<value name="FMT_FIXED_32_32_32" value="0xa"/>
	<value name="FMT_FIXED_32_32_32_32" value="0xb"/>

	<value name="FMT_SHORT_16" value="0x10"/>
	<value name="FMT_SHORT_16_16" value="0x11"/>
	<value name="FMT_SHORT_16_16_16" value="0x12"/>
	<value name="FMT_SHORT_16_16_16_16" value="0x13"/>
	<value name="FMT_USHORT_16" value="0x14"/>
	<value name="FMT_USHORT_16_16" value="0x15"/>
	<value name="FMT_USHORT_16_16_16" value="0x16"/>
	<value name="FMT_USHORT_16_16_16_16" value="0x17"/>
	<value name="FMT_NORM_SHORT_16" value="0x18"/>
	<value name="FMT_NORM_SHORT_16_16" value="0x19"/>
	<value name="FMT_NORM_SHORT_16_16_16" value="0x1a"/>
	<value name="FMT_NORM_SHORT_16_16_16_16" value="0x1b"/>
	<value name="FMT_NORM_USHORT_16" value="0x1c"/>
	<value name="FMT_NORM_USHORT_16_16" value="0x1d"/>
	<value name="FMT_NORM_USHORT_16_16_16" value="0x1e"/>
	<value name="FMT_NORM_USHORT_16_16_16_16" value="0x1f"/>

	<value name="FMT_UBYTE_8" value="0x28"/>
	<value name="FMT_UBYTE_8_8" value="0x29"/>
	<value name="FMT_UBYTE_8_8_8" value="0x2a"/>
	<value name="FMT_UBYTE_8_8_8_8" value="0x2b"/>
	<value name="FMT_NORM_UBYTE_8" value="0x2c"/>
	<value name="FMT_NORM_UBYTE_8_8" value="0x2d"/>
	<value name="FMT_NORM_UBYTE_8_8_8" value="0x2e"/>
	<value name="FMT_NORM_UBYTE_8_8_8_8" value="0x2f"/>
	<value name="FMT_BYTE_8" value="0x30"/>
	<value name="FMT_BYTE_8_8" value="0x31"/>
	<value name="FMT_BYTE_8_8_8" value="0x32"/>
	<value name="FMT_BYTE_8_8_8_8" value="0x33"/>
	<value name="FMT_NORM_BYTE_8" value="0x34"/>
	<value name="FMT_NORM_BYTE_8_8" value="0x35"/>
	<value name="FMT_NORM_BYTE_8_8_8" value="0x36"/>
	<value name="FMT_NORM_BYTE_8_8_8_8" value="0x37"/>
</enum>

<enum name="a3xx_msaa_samples">
	<value name="MSAA_ONE" value="0"/>
	<value name="MSAA_TWO" value="1"/>
	<value name="MSAA_FOUR" value="2"/>
</enum>

<domain name="A3XX" width="32">
	<!-- RBBM registers -->
	<reg32 offset="0x0000" name="RBBM_HW_VERSION"/>
	<reg32 offset="0x0001" name="RBBM_HW_RELEASE"/>
	<reg32 offset="0x0002" name="RBBM_HW_CONFIGURATION"/>
	<reg32 offset="0x0010" name="RBBM_CLOCK_CTL"/>
	<reg32 offset="0x0012" name="RBBM_SP_HYST_CNT"/>
	<reg32 offset="0x0018" name="RBBM_SW_RESET_CMD"/>
	<reg32 offset="0x0020" name="RBBM_AHB_CTL0"/>
	<reg32 offset="0x0021" name="RBBM_AHB_CTL1"/>
	<reg32 offset="0x0022" name="RBBM_AHB_CMD"/>
	<reg32 offset="0x0027" name="RBBM_AHB_ERROR_STATUS"/>
	<reg32 offset="0x002e" name="RBBM_GPR0_CTL"/>
	<reg32 offset="0x0030" name="RBBM_STATUS"/>
	<reg32 offset="0x0033" name="RBBM_WAIT_IDLE_CLOCKS_CTL"/>
	<reg32 offset="0x0050" name="RBBM_INTERFACE_HANG_INT_CTL"/>
	<reg32 offset="0x0051" name="RBBM_INTERFACE_HANG_MASK_CTL0"/>
	<reg32 offset="0x0054" name="RBBM_INTERFACE_HANG_MASK_CTL1"/>
	<reg32 offset="0x0057" name="RBBM_INTERFACE_HANG_MASK_CTL2"/>
	<reg32 offset="0x005a" name="RBBM_INTERFACE_HANG_MASK_CTL3"/>
	<reg32 offset="0x0061" name="RBBM_INT_CLEAR_CMD"/>
	<reg32 offset="0x0063" name="RBBM_INT_0_MASK"/>
	<reg32 offset="0x0064" name="RBBM_INT_0_STATUS"/>
	<reg32 offset="0x0080" name="RBBM_PERFCTR_CTL"/>
	<reg32 offset="0x0088" name="RBBM_GPU_BUSY_MASKED"/>
	<reg32 offset="0x00e0" name="RBBM_PERFCTR_SP_7_LO"/>
	<reg32 offset="0x00e1" name="RBBM_PERFCTR_SP_7_HI"/>
	<reg32 offset="0x00ec" name="RBBM_PERFCTR_PWR_1_LO"/>
	<reg32 offset="0x00ed" name="RBBM_PERFCTR_PWR_1_HI"/>
	<reg32 offset="0x0100" name="RBBM_RBBM_CTL"/>
	<reg32 offset="0x0100" name="RBBM_RBBM_CTL"/>
	<reg32 offset="0x0111" name="RBBM_DEBUG_BUS_CTL"/>
	<reg32 offset="0x0112" name="RBBM_DEBUG_BUS_DATA_STATUS"/>

	<!-- CP registers -->
	<reg32 offset="0x01c9" name="CP_PFP_UCODE_ADDR"/>
	<reg32 offset="0x01ca" name="CP_PFP_UCODE_DATA"/>
	<reg32 offset="0x01cc" name="CP_ROQ_ADDR"/>
	<reg32 offset="0x01cd" name="CP_ROQ_DATA"/>
	<reg32 offset="0x01d1" name="CP_MERCIU_ADDR"/>
	<reg32 offset="0x01d2" name="CP_MERCIU_DATA"/>
	<reg32 offset="0x01d3" name="CP_MERCIU_DATA2"/>
	<reg32 offset="0x01da" name="CP_MEQ_ADDR"/>
	<reg32 offset="0x01db" name="CP_MEQ_DATA"/>
	<reg32 offset="0x045c" name="CP_HW_FAULT"/>
	<reg32 offset="0x045e" name="CP_PROTECT_CTRL"/>
	<reg32 offset="0x045f" name="CP_PROTECT_STATUS"/>
	<array offset="0x0460" name="CP_PROTECT" stride="1" length="16">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<reg32 offset="0x054d" name="CP_AHB_FAULT"/>
	<reg32 offset="0x057a" name="CP_SCRATCH_REG2"/>
	<reg32 offset="0x057b" name="CP_SCRATCH_REG3"/>

	<!-- GRAS registers -->
	<reg32 offset="0x2040" name="GRAS_CL_CLIP_CNTL">
		<bitfield name="IJ_PERSP_CENTER" pos="12" type="boolean"/> <!-- is it more bits? -->
		<bitfield name="CLIP_DISABLE" pos="16" type="boolean"/>
		<bitfield name="ZFAR_CLIP_DISABLE" pos="17" type="boolean"/>
		<bitfield name="VP_CLIP_CODE_IGNORE" pos="19" type="boolean"/>
		<bitfield name="VP_XFORM_DISABLE" pos="20" type="boolean"/>
		<bitfield name="PERSP_DIVISION_DISABLE" pos="21" type="boolean"/>
	</reg32>
	<reg32 offset="0x2044" name="GRAS_CL_GB_CLIP_ADJ">
		<bitfield name="HORZ" low="0" high="9" type="uint"/>
		<bitfield name="VERT" low="10" high="19" type="uint"/>
	</reg32>
	<reg32 offset="0x2048" name="GRAS_CL_VPORT_XOFFSET" type="float"/>
	<reg32 offset="0x2049" name="GRAS_CL_VPORT_XSCALE" type="float"/>
	<reg32 offset="0x204a" name="GRAS_CL_VPORT_YOFFSET" type="float"/>
	<reg32 offset="0x204b" name="GRAS_CL_VPORT_YSCALE" type="float"/>
	<reg32 offset="0x204c" name="GRAS_CL_VPORT_ZOFFSET" type="float"/>
	<reg32 offset="0x204d" name="GRAS_CL_VPORT_ZSCALE" type="float"/>
	<reg32 offset="0x2068" name="GRAS_SU_POINT_MINMAX"/>
	<reg32 offset="0x2069" name="GRAS_SU_POINT_SIZE"/>
	<reg32 offset="0x206c" name="GRAS_SU_POLY_OFFSET_SCALE">
		<bitfield name="VAL" low="0" high="23" type="fixed" radix="20"/>
		<doc>range of -8.0 to 8.0</doc>
	</reg32>
	<reg32 offset="0x206d" name="GRAS_SU_POLY_OFFSET_OFFSET" radix="22" type="fixed">
		<doc>range of -512.0 to 512.0</doc>
	</reg32>
	<reg32 offset="0x2070" name="GRAS_SU_MODE_CONTROL">
		<bitfield name="CULL_FRONT" pos="0" type="boolean"/>
		<bitfield name="CULL_BACK" pos="1" type="boolean"/>
		<!-- guessing on size -->
		<bitfield name="LINEHALFWIDTH" low="2" high="10" type="uint"/>
		<bitfield name="POLY_OFFSET" pos="11" type="boolean"/>
	</reg32>
	<reg32 offset="0x2072" name="GRAS_SC_CONTROL">
		<!-- complete wild-ass-guess for sizes of these bitfields.. -->
		<bitfield name="RENDER_MODE" low="4" high="7" type="a3xx_render_mode"/>
		<bitfield name="MSAA_SAMPLES" low="8" high="11" type="a3xx_msaa_samples"/>
		<bitfield name="RASTER_MODE" low="12" high="15"/>
	</reg32>

	<bitset name="a3xx_reg_xy" inline="yes">
		<bitfield name="WINDOW_OFFSET_DISABLE" pos="31" type="boolean"/>  <!-- I assume it is same as a2xx -->
		<bitfield name="X" low="0" high="14" type="uint"/>
		<bitfield name="Y" low="16" high="30" type="uint"/>
	</bitset>

	<reg32 offset="0x2074" name="GRAS_SC_SCREEN_SCISSOR_TL" type="a3xx_reg_xy"/>
	<reg32 offset="0x2075" name="GRAS_SC_SCREEN_SCISSOR_BR" type="a3xx_reg_xy"/>
	<reg32 offset="0x2079" name="GRAS_SC_WINDOW_SCISSOR_TL" type="a3xx_reg_xy"/>
	<reg32 offset="0x207a" name="GRAS_SC_WINDOW_SCISSOR_BR" type="a3xx_reg_xy"/>

	<!-- RB registers -->
	<reg32 offset="0x20c0" name="RB_MODE_CONTROL">
		<!-- guess on the # of bits here.. -->
		<doc>
			RENDER_MODE is RB_RESOLVE_PASS for gmem->mem, otherwise RB_RENDER_PASS
		</doc>
		<bitfield name="RENDER_MODE" low="8" high="10" type="a3xx_render_mode"/>
		<bitfield name="MARB_CACHE_SPLIT_MODE" pos="15" type="boolean"/>
		<bitfield name="PACKER_TIMER_ENABLE" pos="16" type="boolean"/>
	</reg32>
	<reg32 offset="0x20c1" name="RB_RENDER_CONTROL">
		<bitfield name="BIN_WIDTH" low="4" high="11" shr="5" type="uint"/>
		<bitfield name="DISABLE_COLOR_PIPE" pos="12" type="boolean"/>
		<bitfield name="ALPHA_TEST_FUNC" low="24" high="26" type="adreno_compare_func"/>
	</reg32>
	<reg32 offset="0x20c2" name="RB_MSAA_CONTROL">
		<bitfield name="DISABLE" pos="10" type="boolean"/>
		<bitfield name="SAMPLES" low="12" high="15" type="a3xx_msaa_samples"/>
		<bitfield name="SAMPLE_MASK" low="16" high="31" type="hex"/>
	</reg32>
	<reg32 offset="0x20c3" name="UNKNOWN_20C3">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<array offset="0x20c4" name="RB_MRT" stride="4" length="4">
		<reg32 offset="0x0" name="CONTROL">
			<bitfield name="READ_DEST_ENABLE" pos="3" type="boolean"/>
			<!-- both these bits seem to get set when enabling GL_BLEND.. -->
			<bitfield name="BLEND" pos="4" type="boolean"/>
			<bitfield name="BLEND2" pos="5" type="boolean"/>
			<bitfield name="ROP_CODE" low="8" high="11" type="uint"/>
			<bitfield name="DITHER_MODE" low="12" high="13" type="adreno_rb_dither_mode"/>
			<bitfield name="COMPONENT_ENABLE" low="24" high="27" type="hex"/>
		</reg32>
		<reg32 offset="0x1" name="BUF_INFO">
			<bitfield name="COLOR_FORMAT" low="0" high="5" type="a3xx_color_format"/>
			<bitfield name="COLOR_TILE_MODE" low="6" high="7" type="a3xx_tile_mode"/>
			<doc>
				Pitch (actually, appears to be pitch in bytes, so really is a stride)
				in GMEM, so pitch of the current tile.
			</doc>
			<bitfield name="COLOR_BUF_PITCH" low="17" high="31" shr="5" type="uint"/>
		</reg32>
		<reg32 offset="0x2" name="BUF_BASE">
			<!--
				XXX maybe this is offsets into GMEM.. we seem to get 0x20000
				when depth buffer is enabled.. not sure if that means on
				that the color buffer comes *after* the depth/stencil buffer
				or that there are some high bits in here that are the offset
				of the depth/stencil buffer like on a2xx
			 -->
			<bitfield name="COLOR_BUF_BASE" low="4" high="31" shr="5" type="hex"/>
		</reg32>
		<reg32 offset="0x3" name="BLEND_CONTROL">
			<bitfield name="RGB_SRC_FACTOR" low="0" high="4" type="adreno_rb_blend_factor"/>
			<bitfield name="RGB_BLEND_OPCODE" low="5" high="7" type="adreno_rb_blend_opcode"/>
			<bitfield name="RGB_DEST_FACTOR" low="8" high="12" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_SRC_FACTOR" low="16" high="20" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_BLEND_OPCODE" low="21" high="23" type="adreno_rb_blend_opcode"/>
			<bitfield name="ALPHA_DEST_FACTOR" low="24" high="28" type="adreno_rb_blend_factor"/>
			<bitfield name="CLAMP_ENABLE" pos="29" type="boolean"/>
		</reg32>
	</array>
	<reg32 offset="0x20e4" name="RB_BLEND_RED"/>
	<reg32 offset="0x20e5" name="RB_BLEND_GREEN"/>
	<reg32 offset="0x20e6" name="RB_BLEND_BLUE"/>
	<!--
		seems to be set to either 0x3c0000ff or 0x00000000.. maybe upper
		bits are some field or bitmask??  Or maybe we have different bit-
		fields for each MRT?
	 -->
	<reg32 offset="0x20e7" name="RB_BLEND_ALPHA"/>

	<reg32 offset="0x20e8" name="UNKNOWN_20E8">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x20e9" name="UNKNOWN_20E9">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x20ea" name="UNKNOWN_20EA">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x20eb" name="UNKNOWN_20EB">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<enum name="adreno_rb_copy_control_mode">
		<value name="RB_COPY_RESOLVE" value="1"/>
		<value name="RB_COPY_DEPTH_STENCIL" value="5"/>  <!-- not sure if this is part of MODE or another bitfield?? -->
	</enum>
	<reg32 offset="0x20ec" name="RB_COPY_CONTROL">
		<!-- not sure # of bits -->
		<bitfield name="MSAA_RESOLVE" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="MODE" low="4" high="6" type="adreno_rb_copy_control_mode"/>
		<bitfield name="GMEM_BASE" low="14" high="31" shr="14" type="hex"/>
	</reg32>
	<reg32 offset="0x20ed" name="RB_COPY_DEST_BASE">
		<bitfield name="BASE" low="4" high="31" shr="5" type="hex"/>
	</reg32>
	<reg32 offset="0x20ee" name="RB_COPY_DEST_PITCH">
		<doc>actually, appears to be pitch in bytes, so really is a stride</doc>
		<!-- not actually sure about max pitch... -->
		<bitfield name="PITCH" low="0" high="31" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x20ef" name="RB_COPY_DEST_INFO">
		<bitfield name="TILE" low="0" high="1" type="a3xx_tile_mode"/>
		<bitfield name="FORMAT" low="2" high="7" type="a3xx_color_format"/>
		<bitfield name="COMPONENT_ENABLE" low="14" high="17" type="hex"/>
		<bitfield name="ENDIAN" low="18" high="20" type="adreno_rb_surface_endian"/>
	</reg32>
	<reg32 offset="0x2100" name="RB_DEPTH_CONTROL">
		<!--
			guessing that this matches a2xx with the stencil fields
			moved out into RB_STENCIL_CONTROL?
		 -->
		<bitfield name="Z_ENABLE" pos="1" type="boolean"/>
		<bitfield name="Z_WRITE_ENABLE" pos="2" type="boolean"/>
		<bitfield name="EARLY_Z_ENABLE" pos="3" type="boolean"/>
		<bitfield name="ZFUNC" low="4" high="6" type="adreno_compare_func"/>
		<bitfield name="BF_ENABLE" pos="7" type="boolean"/>
		<doc>Z_TEST_ENABLE bit is set for zfunc other than GL_ALWAYS or GL_NEVER</doc>
		<bitfield name="Z_TEST_ENABLE" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x2101" name="UNKNOWN_2101">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2102" name="RB_DEPTH_INFO">
		<bitfield name="DEPTH_FORMAT" pos="0" type="adreno_rb_depth_format"/>
		<doc>
			DEPTH_BASE is offset in GMEM to depth/stencil buffer, ie
			bin_w * bin_h / 1024 (possible rounded up to multiple of
			something??  ie. 39 becomes 40, 78 becomes 80.. 75 becomes
			80.. so maybe it needs to be multiple of 8??
		</doc>
		<bitfield name="DEPTH_BASE" low="11" high="31" shr="10" type="uint"/>
	</reg32>
	<reg32 offset="0x2103" name="RB_DEPTH_PITCH" shr="4" type="uint">
		<doc>pitch of depth/stencil buffer</doc>
	</reg32>
	<reg32 offset="0x2104" name="RB_STENCIL_CONTROL">
		<bitfield name="STENCIL_ENABLE" pos="0" type="boolean"/>
		<doc>
			STENCIL_ENABLE2 seems to be also set whenever is stencil is
			enabled.. maybe front/back face can be enabled independently?
			a2xx didn't have that (it was more similar to radeon for
			stencil related registers)
		</doc>
		<bitfield name="STENCIL_ENABLE2" pos="2" type="boolean"/>
		<bitfield name="FUNC" low="8" high="10" type="adreno_compare_func"/>
		<bitfield name="FAIL" low="11" high="13" type="adreno_stencil_op"/>
		<bitfield name="ZPASS" low="14" high="16" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL" low="17" high="19" type="adreno_stencil_op"/>
		<bitfield name="FUNC_BF" low="20" high="22" type="adreno_compare_func"/>
		<bitfield name="FAIL_BF" low="23" high="25" type="adreno_stencil_op"/>
		<bitfield name="ZPASS_BF" low="26" high="28" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL_BF" low="29" high="31" type="adreno_stencil_op"/>
	</reg32>
	<reg32 offset="0x2105" name="UNKNOWN_2105">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2106" name="UNKNOWN_2106">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2107" name="UNKNOWN_2107">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2108" name="RB_STENCILREFMASK" type="adreno_rb_stencilrefmask"/>
	<reg32 offset="0x2109" name="RB_STENCILREFMASK_BF" type="adreno_rb_stencilrefmask"/>
	<reg32 offset="0x210e" name="PA_SC_WINDOW_OFFSET">
		<doc>X/Y offset of current bin</doc>
		<bitfield name="X" low="0" high="15" type="uint"/>
		<bitfield name="Y" low="16" high="31" type="uint"/>
	</reg32>

	<!-- PC registers -->
	<reg32 offset="0x21e4" name="PC_VSTREAM_CONTROL"/>
	<reg32 offset="0x21ea" name="PC_VERTEX_REUSE_BLOCK_CNTL"/>
	<reg32 offset="0x21ec" name="PC_PRIM_VTX_CNTL">
		<doc>
			STRIDE_IN_VPC: ALIGN(next_outloc - 8, 4) / 4
			(but, in cases where you'd expect 1, the blob driver uses
			2, so possibly 0 (no varying) or minimum of 2)
		</doc>
		<bitfield name="STRIDE_IN_VPC" low="0" high="4" type="uint"/>
		<bitfield name="POLYMODE_FRONT_PTYPE" low="5" high="7" type="adreno_pa_su_sc_draw"/>
		<bitfield name="POLYMODE_BACK_PTYPE" low="8" high="10" type="adreno_pa_su_sc_draw"/>
		<bitfield name="PROVOKING_VTX_LAST" pos="25" type="boolean"/>
	</reg32>
	<reg32 offset="0x21ed" name="PC_RESTART_INDEX"/>

	<!-- HLSQ registers -->
	<bitset name="a3xx_hlsq_vs_fs_control_reg" inline="yes">
		<bitfield name="CONSTLENGTH" low="0" high="11" type="uint"/>
		<bitfield name="CONSTSTARTOFFSET" low="12" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</bitset>
	<bitset name="a3xx_hlsq_const_vs_fs_presv_range_reg" inline="yes">
		<!-- are these a3xx_regid?? -->
		<bitfield name="STARTENTRY" low="0" high="15"/>
		<bitfield name="ENDENTRY" low="16" high="31"/>
	</bitset>

	<reg32 offset="0x2200" name="HLSQ_CONTROL_0_REG">
		<bitfield name="FSTHREADSIZE" pos="4" type="a3xx_threadsize"/>
		<bitfield name="FSSUPERTHREADENABLE" pos="6" type="boolean"/>
		<bitfield name="SPSHADERRESTART" pos="9" type="boolean"/>
		<bitfield name="RESERVED2" pos="10" type="boolean"/>
		<bitfield name="CHUNKDISABLE" pos="26" type="boolean"/>
		<bitfield name="CONSTSWITCHMODE" pos="27" type="boolean"/>
		<bitfield name="LAZYUPDATEDISABLE" pos="28" type="boolean"/>
		<bitfield name="SPCONSTFULLUPDATE" pos="29" type="boolean"/>
		<bitfield name="TPFULLUPDATE" pos="30" type="boolean"/>
	</reg32>
	<reg32 offset="0x2201" name="HLSQ_CONTROL_1_REG">
		<bitfield name="VSTHREADSIZE" pos="6" type="a3xx_threadsize"/>
		<bitfield name="VSSUPERTHREADENABLE" pos="8" type="boolean"/>
		<bitfield name="RESERVED1" pos="9" type="boolean"/>
	</reg32>
	<reg32 offset="0x2202" name="HLSQ_CONTROL_2_REG">
		<bitfield name="PRIMALLOCTHRESHOLD" low="26" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2203" name="HLSQ_CONTROL_3_REG"/>
	<reg32 offset="0x2204" name="HLSQ_VS_CONTROL_REG" type="a3xx_hlsq_vs_fs_control_reg"/>
	<reg32 offset="0x2205" name="HLSQ_FS_CONTROL_REG" type="a3xx_hlsq_vs_fs_control_reg"/>
	<reg32 offset="0x2206" name="HLSQ_CONST_VSPRESV_RANGE_REG" type="a3xx_hlsq_const_vs_fs_presv_range_reg"/>
	<reg32 offset="0x2207" name="HLSQ_CONST_FSPRESV_RANGE_REG" type="a3xx_hlsq_const_vs_fs_presv_range_reg"/>
	<reg32 offset="0x220a" name="HLSQ_CL_NDRANGE_0_REG"/>
	<reg32 offset="0x220b" name="HLSQ_CL_NDRANGE_1_REG"/>
	<reg32 offset="0x220c" name="HLSQ_CL_NDRANGE_2_REG"/>
	<reg32 offset="0x2211" name="HLSQ_CL_CONTROL_0_REG"/>
	<reg32 offset="0x2212" name="HLSQ_CL_CONTROL_1_REG"/>
	<reg32 offset="0x2214" name="HLSQ_CL_KERNEL_CONST_REG"/>
	<reg32 offset="0x2215" name="HLSQ_CL_KERNEL_GROUP_X_REG"/>
	<reg32 offset="0x2217" name="HLSQ_CL_KERNEL_GROUP_Z_REG"/>
	<reg32 offset="0x221a" name="HLSQ_CL_WG_OFFSET_REG"/>

	<!-- VFD registers -->
	<reg32 offset="0x2240" name="VFD_CONTROL_0">
		<doc>
			TOTALATTRTOVS is # of attributes to vertex shader, in register
			slots (ie. vec4+vec3 -> 7)
		</doc>
		<bitfield name="TOTALATTRTOVS" low="0" high="17" type="uint"/>
		<bitfield name="PACKETSIZE" low="18" high="21" type="uint"/>
		<doc>STRMDECINSTRCNT and STRMFETCHINSTRCNT seem to be set same as MAXSTORAGE</doc>
		<bitfield name="STRMDECINSTRCNT" low="22" high="26" type="uint"/>
		<bitfield name="STRMFETCHINSTRCNT" low="27" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2241" name="VFD_CONTROL_1">
		<doc>MAXSTORAGE could be # of attributes/vbo's</doc>
		<bitfield name="MAXSTORAGE" low="0" high="15" type="uint"/>
		<!--
			always seem to be 252 except when entire register is zero'd,
			but in these cases it is overwritten with non-zero value
			before the next DRAW_INDX
		 -->
		<bitfield name="REGID4VTX" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="REGID4INST" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0x2242" name="VFD_INDEX_MIN" type="uint"/>
	<reg32 offset="0x2243" name="VFD_INDEX_MAX" type="uint"/>
	<reg32 offset="0x2244" name="VFD_INSTANCEID_OFFSET" type="uint"/>
	<reg32 offset="0x2245" name="VFD_INDEX_OFFSET" type="uint"/>
	<array offset="0x2246" name="VFD_FETCH" stride="2" length="16">
		<reg32 offset="0x0" name="INSTR_0">
			<bitfield name="FETCHSIZE" low="0" high="6" type="uint"/>
			<bitfield name="BUFSTRIDE" low="7" high="16" type="uint"/>
			<bitfield name="SWITCHNEXT" pos="17" type="boolean"/>
			<bitfield name="INDEXCODE" low="18" high="23" type="uint"/>
			<bitfield name="STEPRATE" low="24" high="31" type="uint"/>
		</reg32>
		<reg32 offset="0x1" name="INSTR_1"/>
	</array>
	<array offset="0x2266" name="VFD_DECODE" stride="1" length="16">
		<reg32 offset="0x0" name="INSTR">
			<bitfield name="WRITEMASK" low="0" high="3" type="hex"/>
			<!-- not sure if this is a bit flag and another flag above it, or?? -->
			<bitfield name="CONSTFILL" pos="4" type="boolean"/>
			<bitfield name="FORMAT" low="6" high="11" type="a3xx_fmt"/>
			<bitfield name="REGID" low="12" high="19" type="a3xx_regid"/>
			<doc>SHIFTCNT appears to be size, ie. FLOAT_32_32_32 is 12, and BYTE_8 is 1</doc>
			<bitfield name="SHIFTCNT" low="24" high="28" type="uint"/>
			<bitfield name="LASTCOMPVALID" pos="29" type="boolean"/>
			<bitfield name="SWITCHNEXT" pos="30" type="boolean"/>
		</reg32>
	</array>
	<reg32 offset="0x227e" name="VFD_VS_THREADING_THRESHOLD">
		<bitfield name="REGID_THRESHOLD" low="0" high="3" type="uint"/>
		<!-- <bitfield name="RESERVED6" low="4" high="7" type="uint"/> -->
		<bitfield name="REGID_VTXCNT" low="8" high="15" type="a3xx_regid"/>
	</reg32>

	<!-- VPC registers -->
	<reg32 offset="0x2280" name="VPC_ATTR">
		<bitfield name="TOTALATTR" low="0" high="11" type="uint"/>
		<bitfield name="THRDASSIGN" low="12" high="27" type="uint"/>
		<bitfield name="LMSIZE" low="28" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2281" name="VPC_PACK">
		<!-- these are always seem to be set to same as TOTALATTR -->
		<bitfield name="NUMFPNONPOSVAR" low="8" high="15" type="uint"/>
		<bitfield name="NUMNONPOSVSVAR" low="16" high="23" type="uint"/>
	</reg32>
	<!--
		interpolate or interrupt?  former makes sense, but kernel calls
		it both "VARRYING_INTERUPT_MODE_n (sic) and VARYING_INTERP_MODE_n
		(and few other misspell variations..)
	 -->
	<array offset="0x2282" name="VPC_VARYING_INTERP" stride="1" length="4">
		<reg32 offset="0x0" name="MODE"/>
	</array>
	<array offset="0x2286" name="VPC_VARYING_PS_REPL" stride="1" length="4">
		<reg32 offset="0x0" name="MODE"/>
	</array>
	<reg32 offset="0x228a" name="VPC_VARY_CYLWRAP_ENABLE_0"/>
	<reg32 offset="0x228b" name="VPC_VARY_CYLWRAP_ENABLE_1"/>

	<!-- SP registers -->
	<bitset name="a3xx_vs_fs_length_reg" inline="yes">
		<bitfield name="SHADERLENGTH" low="0" high="31" type="uint"/>
	</bitset>
	<bitset name="a3xx_sp_vs_fs_ctrl_reg0" inline="yes">
		<bitfield name="THREADMODE" pos="0" type="a3xx_threadmode"/>
		<bitfield name="INSTRBUFFERMODE" pos="1" type="a3xx_instrbuffermode"/>
		<!-- maybe CACHEINVALID is two bits?? -->
		<bitfield name="CACHEINVALID" pos="2" type="boolean"/>
		<doc>
			The full/half register footprint is in units of four components,
			so if r0.x is used, that counts as all of r0.[xyzw] as used.
			There are separate full/half register footprint values as the
			full and half registers are independent (not overlapping).
			Presumably the thread scheduler hardware allocates the full/half
			register names from the actual physical register file and
			handles the register renaming.
		</doc>
		<bitfield name="HALFREGFOOTPRINT" low="4" high="9" type="uint"/>
		<bitfield name="FULLREGFOOTPRINT" low="10" high="17" type="uint"/>
		<!-- maybe INOUTREGOVERLAP is a bitflag? -->
		<bitfield name="INOUTREGOVERLAP" low="18" high="19" type="uint"/>
		<bitfield name="THREADSIZE" pos="20" type="a3xx_threadsize"/>
		<bitfield name="SUPERTHREADMODE" pos="21" type="boolean"/>
		<bitfield name="PIXLODENABLE" pos="22" type="boolean"/>
		<doc>
			From regspec:
			SP_FS_CTRL_REG0.FS_LENGTH [31:24]: FS length, unit = 256bits.
			If bit31 is 1, it means overflow
			or any long shader.
		</doc>
		<bitfield name="LENGTH" low="24" high="31" type="uint"/>
	</bitset>
	<bitset name="a3xx_sp_vs_fs_ctrl_reg1" inline="yes">
		<bitfield name="CONSTLENGTH" low="0" high="9" type="uint"/>
		<bitfield name="INITIALOUTSTANDING" low="20" high="23" type="uint"/>
		<!-- probably HALFPRECVAROFFSET goes to bit 31?? -->
		<bitfield name="HALFPRECVAROFFSET" low="24" high="29" type="uint"/>
	</bitset>
	<bitset name="sp_vs_fs_obj_offset_reg" inline="yes">
		<doc>
			From register spec:
			SP_FS_OBJ_OFFSET_REG.CONSTOBJECTSTARTOFFSET [16:24]: Constant object
			start offset in on chip RAM,
			128bit aligned
		</doc>
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</bitset>
	<bitset name="a3xx_varying_info" inline="yes">
		<bitfield name="REGID" low="0" high="8" type="a3xx_regid"/>
		<!-- I guess 4 bits.. -->
		<bitfield name="COMPMASK" low="9" high="12" type="hex"/>
	</bitset>

	<reg32 offset="0x22c0" name="SP_SP_CTRL_REG">
		<!-- this bit is set during resolve pass: -->
		<bitfield name="RESOLVE" pos="16" type="boolean"/>
		<!--
			guessing that these are two bits each.. but possibly could
			be just a flag with some other flags in between..
		-->
		<bitfield name="CONSTMODE" low="18" high="19" type="uint"/>
		<bitfield name="SLEEPMODE" low="20" high="21" type="uint"/>
		<bitfield name="LOMODE" low="22" high="23" type="uint"/>
	</reg32>
	<reg32 offset="0x22c4" name="SP_VS_CTRL_REG0" type="a3xx_sp_vs_fs_ctrl_reg0"/>
	<reg32 offset="0x22c5" name="SP_VS_CTRL_REG1" type="a3xx_sp_vs_fs_ctrl_reg1"/>
	<reg32 offset="0x22c6" name="SP_VS_PARAM_REG">
		<bitfield name="POSREGID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="PSIZEREGID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="TOTALVSOUTVAR" low="20" high="31" type="uint"/>
	</reg32>
	<array offset="0x22c7" name="SP_VS_OUT" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A" low="0" high="15" type="a3xx_varying_info"/>
			<bitfield name="B" low="16" high="31" type="a3xx_varying_info"/>
		</reg32>
	</array>
	<array offset="0x22d0" name="SP_VS_VPC_DST" stride="1" length="4">
		<reg32 offset="0x0" name="REG">
			<doc>
				These seem to be offsets for storage of the varyings (within
				SP_VS_OBJ_START_REG?)  Always seems to start from 8, possibly
				loc 0 and 4 are for gl_Position and gl_PointSize?
			</doc>
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>
	<reg32 offset="0x22d4" name="SP_VS_OBJ_OFFSET_REG" type="sp_vs_fs_obj_offset_reg"/>
	<reg32 offset="0x22d5" name="SP_VS_OBJ_START_REG"/>
	<!--
		SP_VS_PVT_MEM_CTRL_REG seems to always be 0x8000001 for gl.. and
		unused for opencl
	 -->
	<reg32 offset="0x22d6" name="SP_VS_PVT_MEM_CTRL_REG"/>
	<reg32 offset="0x22d7" name="SP_VS_PVT_MEM_ADDR_REG"/>
	<reg32 offset="0x22d8" name="SP_VS_PVT_MEM_SIZE_REG"/>
	<reg32 offset="0x22df" name="SP_VS_LENGTH_REG" type="a3xx_vs_fs_length_reg"/>
	<reg32 offset="0x22e0" name="SP_FS_CTRL_REG0" type="a3xx_sp_vs_fs_ctrl_reg0"/>
	<reg32 offset="0x22e1" name="SP_FS_CTRL_REG1" type="a3xx_sp_vs_fs_ctrl_reg1"/>
	<reg32 offset="0x22e2" name="SP_FS_OBJ_OFFSET_REG" type="sp_vs_fs_obj_offset_reg"/>
	<reg32 offset="0x22e3" name="SP_FS_OBJ_START_REG"/>
	<!--
		SP_FS_PVT_MEM_CTRL_REG seems to always be 0x8000001 for gl..  so
		probably only matters for opencl
	 -->
	<reg32 offset="0x22e4" name="SP_FS_PVT_MEM_CTRL_REG"/>
	<reg32 offset="0x22e5" name="SP_FS_PVT_MEM_ADDR_REG"/>
	<reg32 offset="0x22e6" name="SP_FS_PVT_MEM_SIZE_REG"/>
	<reg32 offset="0x22e8" name="SP_FS_FLAT_SHAD_MODE_REG_0"/>
	<reg32 offset="0x22e9" name="SP_FS_FLAT_SHAD_MODE_REG_1"/>
	<reg32 offset="0x22ec" name="SP_FS_OUTPUT_REG"/>
	<array offset="0x22f0" name="SP_FS_MRT" stride="1" length="4">
		<reg32 offset="0x0" name="REG">
			<bitfield name="REGID" low="0" high="7" type="a3xx_regid"/>
			<!-- not really sure about this: size -->
			<!--
				guessing that this indicates half vs full precision output
				register.. need to come up with some tests to confirm this.
				I'd assume we need something similar for VS outputs too..
			 -->
			<bitfield name="PRECISION" pos="8" type="uint"/>
		</reg32>
	</array>
	<array offset="0x22f4" name="SP_FS_IMAGE_OUTPUT" stride="1" length="4">
		<reg32 offset="0x0" name="REG">
			<bitfield name="MRTFORMAT" low="0" high="5" type="a3xx_color_format"/>
		</reg32>
	</array>
	<reg32 offset="0x22ff" name="SP_FS_LENGTH_REG" type="a3xx_vs_fs_length_reg"/>

	<!-- TPL1 registers -->
	<!-- assume VS/FS_TEX_OFFSET is same -->
	<bitset name="a3xx_tpl1_tp_vs_fs_tex_offset" inline="yes">
		<bitfield name="SAMPLEROFFSET" low="0" high="7" type="uint"/>
		<bitfield name="MEMOBJOFFSET" low="8" high="15" type="uint"/>
		<!-- not sure the size of this: -->
		<bitfield name="BASETABLEPTR" low="16" high="31" type="uint"/>
	</bitset>
	<reg32 offset="0x2340" name="TPL1_TP_VS_TEX_OFFSET" type="a3xx_tpl1_tp_vs_fs_tex_offset"/>
	<reg32 offset="0x2341" name="UNKNOWN_2341">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2342" name="TPL1_TP_FS_TEX_OFFSET" type="a3xx_tpl1_tp_vs_fs_tex_offset"/>
	<reg32 offset="0x2343" name="TPL1_TP_FS_BORDER_COLOR_BASE_ADDR"/>

	<!-- VBIF registers -->
	<reg32 offset="0x3001" name="VBIF_CLKON"/>
	<reg32 offset="0x300c" name="VBIF_FIXED_SORT_EN"/>
	<reg32 offset="0x300d" name="VBIF_FIXED_SORT_SEL0"/>
	<reg32 offset="0x300e" name="VBIF_FIXED_SORT_SEL1"/>
	<reg32 offset="0x301c" name="VBIF_ABIT_SORT"/>
	<reg32 offset="0x301d" name="VBIF_ABIT_SORT_CONF"/>
	<reg32 offset="0x302a" name="VBIF_GATE_OFF_WRREQ_EN"/>
	<reg32 offset="0x302c" name="VBIF_IN_RD_LIM_CONF0"/>
	<reg32 offset="0x302d" name="VBIF_IN_RD_LIM_CONF1"/>
	<reg32 offset="0x3030" name="VBIF_IN_WR_LIM_CONF0"/>
	<reg32 offset="0x3031" name="VBIF_IN_WR_LIM_CONF1"/>
	<reg32 offset="0x3034" name="VBIF_OUT_RD_LIM_CONF0"/>
	<reg32 offset="0x3035" name="VBIF_OUT_WR_LIM_CONF0"/>
	<reg32 offset="0x3036" name="VBIF_DDR_OUT_MAX_BURST"/>
	<reg32 offset="0x303c" name="VBIF_ARB_CTL"/>
	<reg32 offset="0x3049" name="VBIF_ROUND_ROBIN_QOS_ARB"/>
	<reg32 offset="0x3058" name="VBIF_OUT_AXI_AMEMTYPE_CONF0"/>
	<reg32 offset="0x305e" name="VBIF_OUT_AXI_AOOO_EN"/>
	<reg32 offset="0x305f" name="VBIF_OUT_AXI_AOOO"/>



	<reg32 offset="0x0c01" name="VSC_BIN_SIZE">
		<bitfield name="WIDTH" low="0" high="4" shr="5" type="uint"/>
		<bitfield name="HEIGHT" low="5" high="9" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x0c02" name="VSC_SIZE_ADDRESS"/>
	<array offset="0x0c06" name="VSC_PIPE" stride="3" length="8">
		<reg32 offset="0x0" name="CONFIG">
			<doc>
				Configures the mapping between VSC_PIPE buffer and
				bin, X/Y specify the bin index in the horiz/vert
				direction (0,0 is upper left, 0,1 is leftmost bin
				on second row, and so on).  W/H specify the number
				of bins assigned to this VSC_PIPE in the horiz/vert
				dimension.
			</doc>
			<bitfield name="X" low="0" high="9" type="uint"/>
			<bitfield name="Y" low="10" high="19" type="uint"/>
			<bitfield name="W" low="20" high="23" type="uint"/>
			<bitfield name="H" low="24" high="27" type="uint"/>
		</reg32>
		<reg32 offset="0x1" name="DATA_ADDRESS"/>
		<reg32 offset="0x2" name="DATA_LENGTH"/>
	</array>
	<reg32 offset="0x0c3d" name="UNKNOWN_0C3D">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<reg32 offset="0x0c81" name="UNKNOWN_0C81">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<array offset="0x0ca0" name="GRAS_CL_USER_PLANE" stride="4" length="6">
		<reg32 offset="0x0" name="X"/>
		<reg32 offset="0x1" name="Y"/>
		<reg32 offset="0x2" name="Z"/>
		<reg32 offset="0x3" name="W"/>
	</array>
	<reg32 offset="0x0cc0" name="RB_GMEM_BASE_ADDR"/>
	<reg32 offset="0x0ce0" name="RB_WINDOW_SIZE">
		<bitfield name="WIDTH" low="0" high="13" type="uint"/>
		<bitfield name="HEIGHT" low="14" high="27" type="uint"/>
	</reg32>
	<reg32 offset="0x0e00" name="UNKNOWN_0E00">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x0e43" name="UNKNOWN_0E43">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<reg32 offset="0x0e44" name="VFD_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0e61" name="VPC_VPC_DEBUG_RAM_SEL"/>
	<reg32 offset="0x0e62" name="VPC_VPC_DEBUG_RAM_READ"/>
	<reg32 offset="0x0e82" name="UCHE_CACHE_MODE_CONTROL_REG"/>
	<reg32 offset="0x0ea0" name="UCHE_CACHE_INVALIDATE0_REG">
		<!-- might be shifted right by 5, assuming 32byte cache line size.. -->
		<bitfield name="ADDR" low="0" high="27" type="hex"/>
	</reg32>
	<reg32 offset="0x0ea1" name="UCHE_CACHE_INVALIDATE1_REG">
		<!-- might be shifted right by 5, assuming 32byte cache line size.. -->
		<bitfield name="ADDR" low="0" high="27" type="hex"/>
		<!-- I'd assume 2 bits, for FLUSH/INVALIDATE/CLEAN? -->
		<bitfield name="OPCODE" low="28" high="29" type="a3xx_cache_opcode"/>
		<bitfield name="ENTIRE_CACHE" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x0ec4" name="UNKNOWN_0EC4">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x0ec8" name="UNKNOWN_0EC8">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x0ecb" name="SP_PERFCOUNTER7_SELECT"/>
	<reg32 offset="0x0ee0" name="UNKNOWN_0EE0">
		<doc>seems to be always set to 0x00000003</doc>
	</reg32>
	<reg32 offset="0x0f03" name="UNKNOWN_0F03">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
</domain>

</database>

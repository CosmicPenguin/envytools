<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">
<import file="freedreno_copyright.xml"/>
<import file="adreno/adreno_common.xml"/>
<import file="adreno/adreno_pm4.xml"/>

<enum name="a4xx_color_fmt">
	<value name="RB4_A8_UNORM" value="0x01"/>
	<value name="RB4_R8_UNORM" value="0x02"/>

	<value name="RB4_R4G4B4A4_UNORM" value="0x08"/>
	<value name="RB4_R5G5B5A1_UNORM" value="0x0a"/>
	<value name="RB4_R5G6R5_UNORM" value="0x0e"/>
	<value name="RB4_R8G8_UNORM" value="0x0f"/>
	<value name="RB4_R8G8_SNORM" value="0x10"/>
	<value name="RB4_R8G8_UINT" value="0x11"/>
	<value name="RB4_R8G8_SINT" value="0x12"/>
	<value name="RB4_R16_FLOAT" value="0x15"/>
	<value name="RB4_R16_UINT" value="0x16"/>
	<value name="RB4_R16_SINT" value="0x17"/>

	<value name="RB4_R8G8B8_UNORM" value="0x19"/>

	<value name="RB4_R8G8B8A8_UNORM" value="0x1a"/>
	<value name="RB4_R8G8B8A8_SNORM" value="0x1c"/>
	<value name="RB4_R8G8B8A8_UINT" value="0x1d"/>
	<value name="RB4_R8G8B8A8_SINT" value="0x1e"/>
	<value name="RB4_R10G10B10A2_UNORM" value="0x1f"/>
	<value name="RB4_R10G10B10A2_UINT" value="0x22"/>
	<value name="RB4_R11G11B10_FLOAT" value="0x27"/>
	<value name="RB4_R16G16_FLOAT" value="0x2a"/>
	<value name="RB4_R16G16_UINT" value="0x2b"/>
	<value name="RB4_R16G16_SINT" value="0x2c"/>
	<value name="RB4_R32_FLOAT" value="0x2d"/>
	<value name="RB4_R32_UINT" value="0x2e"/>
	<value name="RB4_R32_SINT" value="0x2f"/>

	<value name="RB4_R16G16B16A16_FLOAT" value="0x36"/>
	<value name="RB4_R16G16B16A16_UINT" value="0x37"/>
	<value name="RB4_R16G16B16A16_SINT" value="0x38"/>
	<value name="RB4_R32G32_FLOAT" value="0x39"/>
	<value name="RB4_R32G32_UINT" value="0x3a"/>
	<value name="RB4_R32G32_SINT" value="0x3b"/>

	<value name="RB4_R32G32B32A32_FLOAT" value="0x3c"/>
	<value name="RB4_R32G32B32A32_UINT" value="0x3d"/>
	<value name="RB4_R32G32B32A32_SINT" value="0x3e"/>
</enum>

<enum name="a4xx_tile_mode">
	<value name="TILE4_LINEAR" value="0"/>
	<value name="TILE4_3" value="3"/>
</enum>

<!-- assume same as a3xx for now.. -->
<enum name="a4xx_rb_blend_opcode">
	<value name="BLEND_DST_PLUS_SRC" value="0"/>
	<value name="BLEND_SRC_MINUS_DST" value="1"/>
	<value name="BLEND_DST_MINUS_SRC" value="2"/>
	<value name="BLEND_MIN_DST_SRC" value="3"/>
	<value name="BLEND_MAX_DST_SRC" value="4"/>
</enum>


<enum name="a4xx_vtx_fmt" prefix="chipset">
	<!-- hmm, shifted one compared to a3xx?!?  -->
	<value name="VFMT4_32_FLOAT" value="0x1"/>
	<value name="VFMT4_32_32_FLOAT" value="0x2"/>
	<value name="VFMT4_32_32_32_FLOAT" value="0x3"/>
	<value name="VFMT4_32_32_32_32_FLOAT" value="0x4"/>

	<value name="VFMT4_16_FLOAT" value="0x5"/>
	<value name="VFMT4_16_16_FLOAT" value="0x6"/>
	<value name="VFMT4_16_16_16_FLOAT" value="0x7"/>
	<value name="VFMT4_16_16_16_16_FLOAT" value="0x8"/>

	<value name="VFMT4_32_FIXED" value="0x9"/>
	<value name="VFMT4_32_32_FIXED" value="0xa"/>
	<value name="VFMT4_32_32_32_FIXED" value="0xb"/>
	<value name="VFMT4_32_32_32_32_FIXED" value="0xc"/>

	<!-- beyond here it does not appear to be shifted -->
	<value name="VFMT4_16_SINT" value="0x10"/>
	<value name="VFMT4_16_16_SINT" value="0x11"/>
	<value name="VFMT4_16_16_16_SINT" value="0x12"/>
	<value name="VFMT4_16_16_16_16_SINT" value="0x13"/>
	<value name="VFMT4_16_UINT" value="0x14"/>
	<value name="VFMT4_16_16_UINT" value="0x15"/>
	<value name="VFMT4_16_16_16_UINT" value="0x16"/>
	<value name="VFMT4_16_16_16_16_UINT" value="0x17"/>
	<value name="VFMT4_16_SNORM" value="0x18"/>
	<value name="VFMT4_16_16_SNORM" value="0x19"/>
	<value name="VFMT4_16_16_16_SNORM" value="0x1a"/>
	<value name="VFMT4_16_16_16_16_SNORM" value="0x1b"/>
	<value name="VFMT4_16_UNORM" value="0x1c"/>
	<value name="VFMT4_16_16_UNORM" value="0x1d"/>
	<value name="VFMT4_16_16_16_UNORM" value="0x1e"/>
	<value name="VFMT4_16_16_16_16_UNORM" value="0x1f"/>

	<value name="VFMT4_32_UINT" value="0x20"/>
	<value name="VFMT4_32_32_UINT" value="0x21"/>
	<value name="VFMT4_32_32_32_UINT" value="0x22"/>
	<value name="VFMT4_32_32_32_32_UINT" value="0x23"/>
	<value name="VFMT4_32_SINT" value="0x24"/>
	<value name="VFMT4_32_32_SINT" value="0x25"/>
	<value name="VFMT4_32_32_32_SINT" value="0x26"/>
	<value name="VFMT4_32_32_32_32_SINT" value="0x27"/>

	<value name="VFMT4_8_UINT" value="0x28"/>
	<value name="VFMT4_8_8_UINT" value="0x29"/>
	<value name="VFMT4_8_8_8_UINT" value="0x2a"/>
	<value name="VFMT4_8_8_8_8_UINT" value="0x2b"/>
	<value name="VFMT4_8_UNORM" value="0x2c"/>
	<value name="VFMT4_8_8_UNORM" value="0x2d"/>
	<value name="VFMT4_8_8_8_UNORM" value="0x2e"/>
	<value name="VFMT4_8_8_8_8_UNORM" value="0x2f"/>
	<value name="VFMT4_8_SINT" value="0x30"/>
	<value name="VFMT4_8_8_SINT" value="0x31"/>
	<value name="VFMT4_8_8_8_SINT" value="0x32"/>
	<value name="VFMT4_8_8_8_8_SINT" value="0x33"/>
	<value name="VFMT4_8_SNORM" value="0x34"/>
	<value name="VFMT4_8_8_SNORM" value="0x35"/>
	<value name="VFMT4_8_8_8_SNORM" value="0x36"/>
	<value name="VFMT4_8_8_8_8_SNORM" value="0x37"/>

	<!-- note: these also have bit 22 set in VFD_DECODE -->
	<value name="VFMT4_10_10_10_2_UINT" value="0x3c"/>
	<value name="VFMT4_10_10_10_2_UNORM" value="0x3d"/>
	<value name="VFMT4_10_10_10_2_SINT" value="0x3e"/>
	<value name="VFMT4_10_10_10_2_SNORM" value="0x3f"/>
</enum>

<enum name="a4xx_tex_fmt">
	<value name="TFMT4_5_6_5_UNORM" value="0x0b"/>
	<value name="TFMT4_5_5_5_1_UNORM" value="0x0a"/>
	<value name="TFMT4_4_4_4_4_UNORM" value="0x08"/>
	<value name="TFMT4_X8Z24_UNORM" value="0x47"/>

	<value name="TFMT4_10_10_10_2_UNORM" value="0x21"/>
	<value name="TFMT4_A8_UNORM" value="0x03"/>    <!-- GL_ALPHA -->
	<value name="TFMT4_L8_A8_UNORM" value="0xd"/> <!-- GL_LUMINANCE_ALPHA -->

	<!--
		NOTE: GL_ALPHA and GL_LUMINANCE_ALPHA aren't handled in a similar way
		to float16, float32.. but they seem to use non-standard swizzle too..
		perhaps we can ditch that if the pattern follows of 0xn0, 0xn1, 0xn2,
		0xn3 for 1, 2, 3, 4 components respectively..

		Only formats filled in below are the ones that have been observed by
		the blob or tested.. you can guess what the missing ones are..
	 -->

	<value name="TFMT4_8_UNORM" value="0x04"/>     <!-- GL_LUMINANCE -->
	<value name="TFMT4_8_8_UNORM" value="0xe"/>
	<value name="TFMT4_8_8_8_8_UNORM" value="0x1c"/>

	<value name="TFMT4_8_SNORM" value="0x05"/>
	<value name="TFMT4_8_8_SNORM" value="0x0f"/>
	<value name="TFMT4_8_8_8_8_SNORM" value="0x1d"/>

	<value name="TFMT4_8_UINT" value="0x06"/>
	<value name="TFMT4_8_8_UINT" value="0x10"/>
	<value name="TFMT4_8_8_8_8_UINT" value="0x1e"/>

	<value name="TFMT4_8_SINT" value="0x07"/>
	<value name="TFMT4_8_8_SINT" value="0x11"/>
	<value name="TFMT4_8_8_8_8_SINT" value="0x1f"/>

	<value name="TFMT4_16_UINT" value="0x15"/>
	<value name="TFMT4_16_16_UINT" value="0x29"/>
	<value name="TFMT4_16_16_16_16_UINT" value="0x36"/>

	<value name="TFMT4_16_SINT" value="0x16"/>
	<value name="TFMT4_16_16_SINT" value="0x2a"/>
	<value name="TFMT4_16_16_16_16_SINT" value="0x37"/>

	<value name="TFMT4_32_UINT" value="0x2c"/>
	<value name="TFMT4_32_32_UINT" value="0x39"/>
	<value name="TFMT4_32_32_32_32_UINT" value="0x40"/>

	<value name="TFMT4_32_SINT" value="0x2d"/>
	<value name="TFMT4_32_32_SINT" value="0x3a"/>
	<value name="TFMT4_32_32_32_32_SINT" value="0x41"/>

	<value name="TFMT4_16_FLOAT" value="0x14"/>
	<value name="TFMT4_16_16_FLOAT" value="0x28"/>
	<!-- TFMT_16_16_16_FLOAT -->
	<value name="TFMT4_16_16_16_16_FLOAT" value="0x35"/>

	<value name="TFMT4_32_FLOAT" value="0x2b"/>
	<value name="TFMT4_32_32_FLOAT" value="0x38"/>
	<!-- TFMT_32_32_32_FLOAT -->
	<value name="TFMT4_32_32_32_32_FLOAT" value="0x3f"/>

	<value name="TFMT4_9_9_9_E5_FLOAT" value="0x20"/>
	<value name="TFMT4_11_11_10_FLOAT" value="0x25"/>

	<value name="TFMT4_DXT1" value="0x56"/>
	<value name="TFMT4_DXT3" value="0x57"/>
	<value name="TFMT4_DXT5" value="0x58"/>

	<value name="TFMT4_ATC_RGB" value="0x64"/>
	<value name="TFMT4_ATC_RGBA_EXPLICIT" value="0x65"/>
	<value name="TFMT4_ATC_RGBA_INTERPOLATED" value="0x66"/>

	<value name="TFMT4_ETC2_RG11_UNORM" value="0x67"/>
	<value name="TFMT4_ETC2_RG11_SNORM" value="0x68"/>
	<value name="TFMT4_ETC2_R11_UNORM" value="0x69"/>
	<value name="TFMT4_ETC2_R11_SNORM" value="0x6a"/>
	<value name="TFMT4_ETC1" value="0x6b"/>
	<value name="TFMT4_ETC2_RGB8" value="0x6c"/>
	<value name="TFMT4_ETC2_RGBA8" value="0x6d"/>
	<value name="TFMT4_ETC2_RGB8A1" value="0x6e"/>

	<value name="TFMT4_ASTC_4x4" value="0x6f"/>
	<value name="TFMT4_ASTC_5x4" value="0x70"/>
	<value name="TFMT4_ASTC_5x5" value="0x71"/>
	<value name="TFMT4_ASTC_6x5" value="0x72"/>
	<value name="TFMT4_ASTC_6x6" value="0x73"/>
	<value name="TFMT4_ASTC_8x5" value="0x74"/>
	<value name="TFMT4_ASTC_8x6" value="0x75"/>
	<value name="TFMT4_ASTC_8x8" value="0x76"/>
	<value name="TFMT4_ASTC_10x5" value="0x77"/>
	<value name="TFMT4_ASTC_10x6" value="0x78"/>
	<value name="TFMT4_ASTC_10x8" value="0x79"/>
	<value name="TFMT4_ASTC_10x10" value="0x7a"/>
	<value name="TFMT4_ASTC_12x10" value="0x7b"/>
	<value name="TFMT4_ASTC_12x12" value="0x7c"/>

</enum>

<enum name="a4xx_tex_fetchsize">
	<doc>
		Size pixel to fetch, in bytes.  Doesn't seem to be required, setting
		it to 0x0 seems to work ok, but may be less optimal.
	</doc>
	<value name="TFETCH4_1_BYTE"  value="0"/>
	<value name="TFETCH4_2_BYTE"  value="1"/>
	<value name="TFETCH4_4_BYTE"  value="2"/>
	<value name="TFETCH4_8_BYTE"  value="3"/>
	<value name="TFETCH4_16_BYTE" value="4"/>
</enum>

<enum name="a4xx_depth_format">
	<value name="DEPTH4_NONE" value="0"/>
	<value name="DEPTH4_16" value="1"/>
	<value name="DEPTH4_24_8" value="2"/>
	<value name="DEPTH4_32" value="3"/>
</enum>

<enum name="a4xx_tess_spacing">
	<value name="EQUAL_SPACING" value="0"/>
	<value name="ODD_SPACING" value="2"/>
	<value name="EVEN_SPACING" value="3"/>
</enum>

<domain name="A4XX" width="32">
	<!-- RB registers -->
	<reg32 offset="0x0cc0" name="RB_GMEM_BASE_ADDR"/>
	<reg32 offset="0x0cc7" name="RB_PERFCTR_RB_SEL_0"/>
	<reg32 offset="0x0cc8" name="RB_PERFCTR_RB_SEL_1"/>
	<reg32 offset="0x0cc9" name="RB_PERFCTR_RB_SEL_2"/>
	<reg32 offset="0x0cca" name="RB_PERFCTR_RB_SEL_3"/>
	<reg32 offset="0x0ccb" name="RB_PERFCTR_RB_SEL_4"/>
	<reg32 offset="0x0ccc" name="RB_PERFCTR_RB_SEL_5"/>
	<reg32 offset="0x0ccd" name="RB_PERFCTR_RB_SEL_6"/>
	<reg32 offset="0x0cce" name="RB_PERFCTR_RB_SEL_7"/>
	<reg32 offset="0x0cd2" name="RB_PERFCTR_CCU_SEL_3"/>
	<reg32 offset="0x0ce0" name="RB_FRAME_BUFFER_DIMENSION">
		<bitfield name="WIDTH" low="0" high="13" type="uint"/>
		<bitfield name="HEIGHT" low="16" high="29" type="uint"/>
	</reg32>
	<reg32 offset="0x20cc" name="RB_CLEAR_COLOR_DW0"/>
	<reg32 offset="0x20cd" name="RB_CLEAR_COLOR_DW1"/>
	<reg32 offset="0x20ce" name="RB_CLEAR_COLOR_DW2"/>
	<reg32 offset="0x20cf" name="RB_CLEAR_COLOR_DW3"/>
	<reg32 offset="0x20a0" name="RB_MODE_CONTROL">
		<!--
		for non-bypass mode, these are bin width/height..  although
		possibly bigger bitfields to hold entire width/height for
		gmem-bypass??  Either way, it appears to need to be multiple
		of 32..
		-->
		<bitfield name="WIDTH" low="0" high="5" shr="5" type="uint"/>
		<bitfield name="HEIGHT" low="8" high="13" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x20a1" name="RB_RENDER_CONTROL">
		<bitfield name="BINNING_PASS" pos="0" type="boolean"/>
		<!-- nearly everything has bit3 set.. -->
		<!-- bit5 set on resolve and tiling pass -->
		<bitfield name="DISABLE_COLOR_PIPE" pos="5" type="boolean"/>
	</reg32>
	<reg32 offset="0x20a2" name="RB_MSAA_CONTROL">
		<bitfield name="DISABLE" pos="12" type="boolean"/>
		<bitfield name="SAMPLES" low="13" high="15" type="uint"/>
	</reg32>
	<reg32 offset="0x20a3" name="RB_RENDER_CONTROL2">
		<bitfield name="XCOORD" pos="0" type="boolean"/>
		<bitfield name="YCOORD" pos="1" type="boolean"/>
		<!-- assuming zcoord/wcoord follows.. -->
		<bitfield name="ZCOORD" pos="2" type="boolean"/>
		<bitfield name="WCOORD" pos="3" type="boolean"/>
		<bitfield name="SAMPLEMASK" pos="4" type="boolean"/>
		<bitfield name="FACENESS" pos="5" type="boolean"/>
		<bitfield name="SAMPLEID" pos="6" type="boolean"/>
		<bitfield name="MSAA_SAMPLES" low="7" high="9" type="uint"/>
		<bitfield name="SAMPLEID_HR" pos="11" type="boolean"/>
		<bitfield name="VARYING" pos="12" type="boolean"/>
	</reg32>
	<array offset="0x20a4" name="RB_MRT" stride="5" length="8">
		<reg32 offset="0x0" name="CONTROL">
			<bitfield name="READ_DEST_ENABLE" pos="3" type="boolean"/>
			<!-- both these bits seem to get set when enabling GL_BLEND.. -->
			<bitfield name="BLEND" pos="4" type="boolean"/>
			<bitfield name="BLEND2" pos="5" type="boolean"/>
			<!-- bit10 set when RB_RESOLVE_PASS+RB_COPY_CLEAR -->
			<bitfield name="FASTCLEAR" pos="10" type="boolean"/>
			<!-- bit11 set for everything bit binning pass? -->
			<bitfield name="B11" pos="11" type="boolean"/>
			<bitfield name="COMPONENT_ENABLE" low="24" high="27" type="hex"/>
		</reg32>
		<reg32 offset="0x1" name="BUF_INFO">
			<bitfield name="COLOR_FORMAT" low="0" high="5" type="a4xx_color_fmt"/>
			<!--
			    guestimate position of COLOR_TILE_MODE..  this works out if
			    common value is 2, like on a3xx..
			 -->
			<bitfield name="COLOR_TILE_MODE" low="6" high="7" type="a4xx_tile_mode"/>
			<bitfield name="DITHER_MODE" low="9" high="10" type="adreno_rb_dither_mode"/>
			<bitfield name="COLOR_SWAP" low="11" high="12" type="a3xx_color_swap"/>
			<bitfield name="COLOR_SRGB" pos="13" type="boolean"/>
			<!-- note: possibly some # of lsb's aren't there: -->
			<doc>
				Pitch (actually, appears to be pitch in bytes, so really is a stride)
				in GMEM, so pitch of the current tile.
			</doc>
			<bitfield name="COLOR_BUF_PITCH" low="14" high="31" shr="4" type="uint"/>
		</reg32>
		<reg32 offset="0x2" name="BASE"/>
		<reg32 offset="0x3" name="CONTROL3">
			<!-- probably missing some lsb's.. and guessing upper size -->
			<!-- pitch * cpp * msaa: -->
			<bitfield name="STRIDE" low="3" high="25" type="uint"/>
		</reg32>
		<reg32 offset="0x4" name="BLEND_CONTROL">
			<bitfield name="RGB_SRC_FACTOR" low="0" high="4" type="adreno_rb_blend_factor"/>
			<bitfield name="RGB_BLEND_OPCODE" low="5" high="7" type="a4xx_rb_blend_opcode"/>
			<bitfield name="RGB_DEST_FACTOR" low="8" high="12" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_SRC_FACTOR" low="16" high="20" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_BLEND_OPCODE" low="21" high="23" type="a4xx_rb_blend_opcode"/>
			<bitfield name="ALPHA_DEST_FACTOR" low="24" high="28" type="adreno_rb_blend_factor"/>
		</reg32>
	</array>

	<reg32 offset="0x20f0" name="RB_BLEND_RED">
		<bitfield name="UINT" low="0" high="15" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20f1" name="RB_BLEND_RED_F32" type="float"/>

	<reg32 offset="0x20f2" name="RB_BLEND_GREEN">
		<bitfield name="UINT" low="0" high="15" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20f3" name="RB_BLEND_GREEN_F32" type="float"/>

	<reg32 offset="0x20f4" name="RB_BLEND_BLUE">
		<bitfield name="UINT" low="0" high="15" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20f5" name="RB_BLEND_BLUE_F32" type="float"/>

	<reg32 offset="0x20f6" name="RB_BLEND_ALPHA">
		<bitfield name="UINT" low="0" high="15" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20f7" name="RB_BLEND_ALPHA_F32" type="float"/>

	<reg32 offset="0x20f8" name="RB_ALPHA_CONTROL">
		<bitfield name="ALPHA_REF" low="0" high="7" type="hex"/>
		<bitfield name="ALPHA_TEST" pos="8" type="boolean"/>
		<bitfield name="ALPHA_TEST_FUNC" low="9" high="11" type="adreno_compare_func"/>
	</reg32>
	<reg32 offset="0x20f9" name="RB_FS_OUTPUT">
		<!-- per-mrt enable bit -->
		<bitfield name="ENABLE_BLEND" low="0" high="7"/>
		<!-- else bit8 set when RB_RESOLVE_PASS+RB_COPY_CLEAR -->
		<bitfield name="FAST_CLEAR" pos="8" type="boolean"/>
		<!-- a guess? -->
		<bitfield name="SAMPLE_MASK" low="16" high="31"/>
	</reg32>
	<reg32 offset="0x20fa" name="RB_SAMPLE_COUNT_CONTROL">
		<bitfield name="COPY" pos="1" type="boolean"/>
		<bitfield name="ADDR" low="2" high="31" shr="2"/>
	</reg32>
	<!-- always 00000000 for binning pass, else 0000000f: -->
	<reg32 offset="0x20fb" name="RB_RENDER_COMPONENTS">
		<bitfield name="RT0" low="0" high="3"/>
		<bitfield name="RT1" low="4" high="7"/>
		<bitfield name="RT2" low="8" high="11"/>
		<bitfield name="RT3" low="12" high="15"/>
		<bitfield name="RT4" low="16" high="19"/>
		<bitfield name="RT5" low="20" high="23"/>
		<bitfield name="RT6" low="24" high="27"/>
		<bitfield name="RT7" low="28" high="31"/>
	</reg32>

	<reg32 offset="0x20fc" name="RB_COPY_CONTROL">
		<!-- not sure # of bits -->
		<bitfield name="MSAA_RESOLVE" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="MODE" low="4" high="6" type="adreno_rb_copy_control_mode"/>
		<bitfield name="FASTCLEAR" low="8" high="11" type="hex"/>
		<bitfield name="GMEM_BASE" low="14" high="31" shr="14" type="hex"/>
	</reg32>
	<reg32 offset="0x20fd" name="RB_COPY_DEST_BASE">
		<bitfield name="BASE" low="5" high="31" shr="5" type="hex"/>
	</reg32>
	<reg32 offset="0x20fe" name="RB_COPY_DEST_PITCH">
		<doc>actually, appears to be pitch in bytes, so really is a stride</doc>
		<!-- not actually sure about max pitch... -->
		<bitfield name="PITCH" low="0" high="31" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x20ff" name="RB_COPY_DEST_INFO">
		<bitfield name="FORMAT" low="2" high="7" type="a4xx_color_fmt"/>
		<bitfield name="SWAP" low="8" high="9" type="a3xx_color_swap"/>
		<bitfield name="DITHER_MODE" low="10" high="11" type="adreno_rb_dither_mode"/>
		<bitfield name="COMPONENT_ENABLE" low="14" high="17" type="hex"/>
		<bitfield name="ENDIAN" low="18" high="20" type="adreno_rb_surface_endian"/>
		<bitfield name="TILE" low="24" high="25" type="a4xx_tile_mode"/>
	</reg32>
	<reg32 offset="0x2100" name="RB_FS_OUTPUT_REG">
		<!-- bit0 set except for binning pass.. -->
		<bitfield name="MRT" low="0" high="3" type="uint"/>
		<bitfield name="FRAG_WRITES_Z" pos="5" type="boolean"/>
	</reg32>
	<reg32 offset="0x2101" name="RB_DEPTH_CONTROL">
		<!--
			guessing that this matches a2xx with the stencil fields
			moved out into RB_STENCIL_CONTROL?
		 -->
		<bitfield name="FRAG_WRITES_Z" pos="0" type="boolean"/>
		<bitfield name="Z_ENABLE" pos="1" type="boolean"/>
		<bitfield name="Z_WRITE_ENABLE" pos="2" type="boolean"/>
		<bitfield name="ZFUNC" low="4" high="6" type="adreno_compare_func"/>
		<bitfield name="BF_ENABLE" pos="7" type="boolean"/>
		<bitfield name="EARLY_Z_DISABLE" pos="16" type="boolean"/>
		<doc>Z_TEST_ENABLE bit is set for zfunc other than GL_ALWAYS or GL_NEVER</doc>
		<bitfield name="Z_TEST_ENABLE" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x2102" name="RB_DEPTH_CLEAR"/>
	<reg32 offset="0x2103" name="RB_DEPTH_INFO">
		<bitfield name="DEPTH_FORMAT" low="0" high="1" type="a4xx_depth_format"/>
		<doc>
			DEPTH_BASE is offset in GMEM to depth/stencil buffer, ie
			bin_w * bin_h / 1024 (possible rounded up to multiple of
			something??  ie. 39 becomes 40, 78 becomes 80.. 75 becomes
			80.. so maybe it needs to be multiple of 8??
		</doc>
		<bitfield name="DEPTH_BASE" low="12" high="31" shr="12" type="hex"/>
	</reg32>
	<reg32 offset="0x2104" name="RB_DEPTH_PITCH" shr="5" type="uint">
		<doc>stride of depth/stencil buffer</doc>
	</reg32>
	<reg32 offset="0x2105" name="RB_DEPTH_PITCH2" shr="5" type="uint">
		<doc>???</doc>
	</reg32>
	<reg32 offset="0x2106" name="RB_STENCIL_CONTROL">
		<bitfield name="STENCIL_ENABLE" pos="0" type="boolean"/>
		<bitfield name="STENCIL_ENABLE_BF" pos="1" type="boolean"/>
		<!--
			set for stencil operations that require read from stencil
			buffer, but not for example for stencil clear (which does
			not require read).. so guessing this is analogous to
			READ_DEST_ENABLE for color buffer..
		 -->
		<bitfield name="STENCIL_READ" pos="2" type="boolean"/>
		<bitfield name="FUNC" low="8" high="10" type="adreno_compare_func"/>
		<bitfield name="FAIL" low="11" high="13" type="adreno_stencil_op"/>
		<bitfield name="ZPASS" low="14" high="16" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL" low="17" high="19" type="adreno_stencil_op"/>
		<bitfield name="FUNC_BF" low="20" high="22" type="adreno_compare_func"/>
		<bitfield name="FAIL_BF" low="23" high="25" type="adreno_stencil_op"/>
		<bitfield name="ZPASS_BF" low="26" high="28" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL_BF" low="29" high="31" type="adreno_stencil_op"/>
	</reg32>
	<reg32 offset="0x2107" name="RB_STENCIL_CONTROL2">
		<!--
		This seems to be set by blob if there is a stencil buffer
		at all in GMEM, regardless of whether it is enabled for
		a particular draw (ie. RB_STENCIL_CONTROL).  Not really
		sure if that is required or just a quirk of the blob
		-->
		<bitfield name="STENCIL_BUFFER" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x2108" name="RB_STENCIL_INFO">
		<bitfield name="SEPARATE_STENCIL" pos="0" type="boolean"/>
		<doc>Base address for stencil when not using interleaved depth/stencil</doc>
		<bitfield name="STENCIL_BASE" low="12" high="31" shr="12" type="hex"/>
	</reg32>
	<reg32 offset="0x2109" name="RB_STENCIL_PITCH" shr="5" type="uint">
		<doc>pitch of stencil buffer when not using interleaved depth/stencil</doc>
	</reg32>

	<reg32 offset="0x210b" name="RB_STENCILREFMASK" type="adreno_rb_stencilrefmask"/>
	<reg32 offset="0x210c" name="RB_STENCILREFMASK_BF" type="adreno_rb_stencilrefmask"/>
	<reg32 offset="0x210d" name="RB_BIN_OFFSET" type="adreno_reg_xy"/>
	<array offset="0x2120" name="RB_VPORT_Z_CLAMP" stride="2" length="16">
		<reg32 offset="0x0" name="MIN"/>
		<reg32 offset="0x1" name="MAX"/>
	</array>

	<!-- RBBM registers -->
	<reg32 offset="0x0000" name="RBBM_HW_VERSION"/>
	<reg32 offset="0x0002" name="RBBM_HW_CONFIGURATION"/>
	<array offset="0x4" name="RBBM_CLOCK_CTL_TP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x8" name="RBBM_CLOCK_CTL2_TP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0xc" name="RBBM_CLOCK_HYST_TP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x10" name="RBBM_CLOCK_DELAY_TP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<reg32 offset="0x0014" name="RBBM_CLOCK_CTL_UCHE "/>
	<reg32 offset="0x0015" name="RBBM_CLOCK_CTL2_UCHE"/>
	<reg32 offset="0x0016" name="RBBM_CLOCK_CTL3_UCHE"/>
	<reg32 offset="0x0017" name="RBBM_CLOCK_CTL4_UCHE"/>
	<reg32 offset="0x0018" name="RBBM_CLOCK_HYST_UCHE"/>
	<reg32 offset="0x0019" name="RBBM_CLOCK_DELAY_UCHE"/>
	<reg32 offset="0x001a" name="RBBM_CLOCK_MODE_GPC"/>
	<reg32 offset="0x001b" name="RBBM_CLOCK_DELAY_GPC"/>
	<reg32 offset="0x001c" name="RBBM_CLOCK_HYST_GPC"/>
	<reg32 offset="0x001d" name="RBBM_CLOCK_CTL_TSE_RAS_RBBM"/>
	<reg32 offset="0x001e" name="RBBM_CLOCK_HYST_TSE_RAS_RBBM"/>
	<reg32 offset="0x001f" name="RBBM_CLOCK_DELAY_TSE_RAS_RBBM"/>
	<reg32 offset="0x0020" name="RBBM_CLOCK_CTL"/>
	<reg32 offset="0x0021" name="RBBM_SP_HYST_CNT"/>
	<reg32 offset="0x0022" name="RBBM_SW_RESET_CMD"/>
	<reg32 offset="0x0023" name="RBBM_AHB_CTL0"/>
	<reg32 offset="0x0024" name="RBBM_AHB_CTL1"/>
	<reg32 offset="0x0025" name="RBBM_AHB_CMD"/>
	<reg32 offset="0x0026" name="RBBM_RB_SUB_BLOCK_SEL_CTL"/>
	<reg32 offset="0x0028" name="RBBM_RAM_ACC_63_32"/>
	<reg32 offset="0x002b" name="RBBM_WAIT_IDLE_CLOCKS_CTL"/>
	<reg32 offset="0x002f" name="RBBM_INTERFACE_HANG_INT_CTL"/>
	<reg32 offset="0x0034" name="RBBM_INTERFACE_HANG_MASK_CTL4"/>
	<reg32 offset="0x0036" name="RBBM_INT_CLEAR_CMD"/>
	<reg32 offset="0x0037" name="RBBM_INT_0_MASK"/>
	<reg32 offset="0x003e" name="RBBM_RBBM_CTL"/>
	<reg32 offset="0x003f" name="RBBM_AHB_DEBUG_CTL"/>
	<reg32 offset="0x0041" name="RBBM_VBIF_DEBUG_CTL"/>
	<reg32 offset="0x0042" name="RBBM_CLOCK_CTL2"/>
	<reg32 offset="0x0045" name="RBBM_BLOCK_SW_RESET_CMD"/>
	<reg32 offset="0x0047" name="RBBM_RESET_CYCLES"/>
	<reg32 offset="0x0049" name="RBBM_EXT_TRACE_BUS_CTL"/>
	<reg32 offset="0x004a" name="RBBM_CFG_DEBBUS_SEL_A"/>
	<reg32 offset="0x004b" name="RBBM_CFG_DEBBUS_SEL_B"/>
	<reg32 offset="0x004c" name="RBBM_CFG_DEBBUS_SEL_C"/>
	<reg32 offset="0x004d" name="RBBM_CFG_DEBBUS_SEL_D"/>
	<reg32 offset="0x009c" name="RBBM_PERFCTR_CP_0_LO"/>
	<array offset="0x0068" name="RBBM_CLOCK_CTL_SP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x006c" name="RBBM_CLOCK_CTL2_SP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x0070" name="RBBM_CLOCK_HYST_SP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x0074" name="RBBM_CLOCK_DELAY_SP" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x0078" name="RBBM_CLOCK_CTL_RB" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x007c" name="RBBM_CLOCK_CTL2_RB" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x0082" name="RBBM_CLOCK_CTL_MARB_CCU" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x0086" name="RBBM_CLOCK_HYST_RB_MARB_CCU" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<reg32 offset="0x0080" name="RBBM_CLOCK_HYST_COM_DCOM"/>
	<reg32 offset="0x0081" name="RBBM_CLOCK_CTL_COM_DCOM"/>
	<reg32 offset="0x008a" name="RBBM_CLOCK_CTL_HLSQ"/>
	<reg32 offset="0x008b" name="RBBM_CLOCK_HYST_HLSQ"/>
	<reg32 offset="0x008c" name="RBBM_CLOCK_DELAY_HLSQ"/>
	<bitset name="A4XX_CGC_HLSQ">
		<bitfield name="EARLY_CYC" low="20" high="22" type="uint"/>
	</bitset>
	<reg32 offset="0x008d" name="RBBM_CLOCK_DELAY_COM_DCOM"/>
	<array offset="0x008e" name="RBBM_CLOCK_DELAY_RB_MARB_CCU_L1" stride="1" length="4">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<bitset name="A4XX_INT0">
		<bitfield name="RBBM_GPU_IDLE" pos="0"/>
		<bitfield name="RBBM_AHB_ERROR" pos="1"/>
		<bitfield name="RBBM_REG_TIMEOUT" pos="2"/>
		<bitfield name="RBBM_ME_MS_TIMEOUT" pos="3"/>
		<bitfield name="RBBM_PFP_MS_TIMEOUT" pos="4"/>
		<bitfield name="RBBM_ATB_BUS_OVERFLOW" pos="5"/>
		<bitfield name="VFD_ERROR" pos="6"/>
		<bitfield name="CP_SW_INT" pos="7"/>
		<bitfield name="CP_T0_PACKET_IN_IB" pos="8"/>
		<bitfield name="CP_OPCODE_ERROR" pos="9"/>
		<bitfield name="CP_RESERVED_BIT_ERROR" pos="10"/>
		<bitfield name="CP_HW_FAULT" pos="11"/>
		<bitfield name="CP_DMA" pos="12"/>
		<bitfield name="CP_IB2_INT" pos="13"/>
		<bitfield name="CP_IB1_INT" pos="14"/>
		<bitfield name="CP_RB_INT" pos="15"/>
		<bitfield name="CP_REG_PROTECT_FAULT" pos="16"/>
		<bitfield name="CP_RB_DONE_TS" pos="17"/>
		<bitfield name="CP_VS_DONE_TS" pos="18"/>
		<bitfield name="CP_PS_DONE_TS" pos="19"/>
		<bitfield name="CACHE_FLUSH_TS" pos="20"/>
		<bitfield name="CP_AHB_ERROR_HALT" pos="21"/>
		<bitfield name="MISC_HANG_DETECT" pos="24"/>
		<bitfield name="UCHE_OOB_ACCESS" pos="25"/>
	</bitset>

	<reg32 offset="0x0168" name="RBBM_PERFCTR_PWR_1_LO"/>
	<reg32 offset="0x0170" name="RBBM_PERFCTR_CTL"/>
	<reg32 offset="0x0171" name="RBBM_PERFCTR_LOAD_CMD0"/>
	<reg32 offset="0x0172" name="RBBM_PERFCTR_LOAD_CMD1"/>
	<reg32 offset="0x0173" name="RBBM_PERFCTR_LOAD_CMD2"/>
	<reg32 offset="0x0174" name="RBBM_PERFCTR_LOAD_VALUE_LO"/>
	<reg32 offset="0x0175" name="RBBM_PERFCTR_LOAD_VALUE_HI"/>
	<reg32 offset="0x017a" name="RBBM_GPU_BUSY_MASKED"/>
	<reg32 offset="0x017d" name="RBBM_INT_0_STATUS"/>
	<reg32 offset="0x0182" name="RBBM_CLOCK_STATUS"/>
	<reg32 offset="0x0189" name="RBBM_AHB_STATUS"/>
	<reg32 offset="0x018c" name="RBBM_AHB_ME_SPLIT_STATUS"/>
	<reg32 offset="0x018d" name="RBBM_AHB_PFP_SPLIT_STATUS"/>
	<reg32 offset="0x018f" name="RBBM_AHB_ERROR_STATUS"/>
	<reg32 offset="0x0191" name="RBBM_STATUS">
		<bitfield name="HI_BUSY" pos="0" type="boolean"/>
		<bitfield name="CP_ME_BUSY" pos="1" type="boolean"/>
		<bitfield name="CP_PFP_BUSY" pos="2" type="boolean"/>
		<bitfield name="CP_NRT_BUSY" pos="14" type="boolean"/>
		<bitfield name="VBIF_BUSY" pos="15" type="boolean"/>
		<bitfield name="TSE_BUSY" pos="16" type="boolean"/>
		<bitfield name="RAS_BUSY" pos="17" type="boolean"/>
		<bitfield name="RB_BUSY" pos="18" type="boolean"/>
		<bitfield name="PC_DCALL_BUSY" pos="19" type="boolean"/>
		<bitfield name="PC_VSD_BUSY" pos="20" type="boolean"/>
		<bitfield name="VFD_BUSY" pos="21" type="boolean"/>
		<bitfield name="VPC_BUSY" pos="22" type="boolean"/>
		<bitfield name="UCHE_BUSY" pos="23" type="boolean"/>
		<bitfield name="SP_BUSY" pos="24" type="boolean"/>
		<bitfield name="TPL1_BUSY" pos="25" type="boolean"/>
		<bitfield name="MARB_BUSY" pos="26" type="boolean"/>
		<bitfield name="VSC_BUSY" pos="27" type="boolean"/>
		<bitfield name="ARB_BUSY" pos="28" type="boolean"/>
		<bitfield name="HLSQ_BUSY" pos="29" type="boolean"/>
		<bitfield name="GPU_BUSY_NOHC" pos="30" type="boolean"/>
		<bitfield name="GPU_BUSY" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x019f" name="RBBM_INTERFACE_RRDY_STATUS5"/>

	<!-- CP registers -->
	<reg32 offset="0x0228" name="CP_SCRATCH_UMASK"/>
	<reg32 offset="0x0229" name="CP_SCRATCH_ADDR"/>
	<reg32 offset="0x0200" name="CP_RB_BASE"/>
	<reg32 offset="0x0201" name="CP_RB_CNTL"/>
	<reg32 offset="0x0205" name="CP_RB_WPTR"/>
	<reg32 offset="0x0203" name="CP_RB_RPTR_ADDR"/>
	<reg32 offset="0x0204" name="CP_RB_RPTR"/>
	<reg32 offset="0x0206" name="CP_IB1_BASE"/>
	<reg32 offset="0x0207" name="CP_IB1_BUFSZ"/>
	<reg32 offset="0x0208" name="CP_IB2_BASE"/>
	<reg32 offset="0x0209" name="CP_IB2_BUFSZ"/>
	<reg32 offset="0x020c" name="CP_ME_NRT_ADDR"/>
	<reg32 offset="0x020d" name="CP_ME_NRT_DATA"/>
	<reg32 offset="0x0217" name="CP_ME_RB_DONE_DATA"/>
	<reg32 offset="0x0219" name="CP_QUEUE_THRESH2"/>
	<reg32 offset="0x021b" name="CP_MERCIU_SIZE"/>
	<reg32 offset="0x021c" name="CP_ROQ_ADDR"/>
	<reg32 offset="0x021d" name="CP_ROQ_DATA"/>
	<reg32 offset="0x021e" name="CP_MEQ_ADDR"/>
	<reg32 offset="0x021f" name="CP_MEQ_DATA"/>
	<reg32 offset="0x0220" name="CP_MERCIU_ADDR"/>
	<reg32 offset="0x0221" name="CP_MERCIU_DATA"/>
	<reg32 offset="0x0222" name="CP_MERCIU_DATA2"/>
	<reg32 offset="0x0223" name="CP_PFP_UCODE_ADDR"/>
	<reg32 offset="0x0224" name="CP_PFP_UCODE_DATA"/>
	<reg32 offset="0x0225" name="CP_ME_RAM_WADDR"/>
	<reg32 offset="0x0226" name="CP_ME_RAM_RADDR"/>
	<reg32 offset="0x0227" name="CP_ME_RAM_DATA"/>
	<reg32 offset="0x022a" name="CP_PREEMPT"/>
	<reg32 offset="0x022c" name="CP_CNTL"/>
	<reg32 offset="0x022d" name="CP_ME_CNTL"/>
	<reg32 offset="0x022e" name="CP_DEBUG"/>
	<reg32 offset="0x0231" name="CP_DEBUG_ECO_CONTROL"/>
	<reg32 offset="0x0232" name="CP_DRAW_STATE_ADDR"/>
	<reg32 offset="0x0240" name="CP_PROTECT_REG_0"/>
	<array offset="0x0240" name="CP_PROTECT" stride="1" length="16">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<reg32 offset="0x0250" name="CP_PROTECT_CTRL"/>
	<reg32 offset="0x04c0" name="CP_ST_BASE"/>
	<reg32 offset="0x04ce" name="CP_STQ_AVAIL"/>
	<reg32 offset="0x04d0" name="CP_MERCIU_STAT"/>
	<reg32 offset="0x04d2" name="CP_WFI_PEND_CTR"/>
	<reg32 offset="0x04d8" name="CP_HW_FAULT"/>
	<reg32 offset="0x04da" name="CP_PROTECT_STATUS"/>
	<reg32 offset="0x04dd" name="CP_EVENTS_IN_FLIGHT"/>
	<reg32 offset="0x0500" name="CP_PERFCTR_CP_SEL_0"/>
	<reg32 offset="0x050b" name="CP_PERFCOMBINER_SELECT"/>
	<array offset="0x0578" name="CP_SCRATCH" stride="1" length="23">
		<reg32 offset="0x0" name="REG"/>
	</array>

	<!-- SP registers -->
	<reg32 offset="0x0ec0" name="SP_VS_STATUS"/>
	<reg32 offset="0x0ec3" name="SP_MODE_CONTROL"/>
	<reg32 offset="0x0ecf" name="SP_PERFCTR_SP_SEL_11"/>
	<reg32 offset="0x22c0" name="SP_SP_CTRL_REG">
		<bitfield name="BINNING_PASS" pos="19" type="boolean"/>
	</reg32>
	<reg32 offset="0x22c1" name="SP_INSTR_CACHE_CTRL">
		<!-- set when VS in buffer mode: -->
		<bitfield name="VS_BUFFER" pos="7" type="boolean"/>
		<!-- set when FS in buffer mode: -->
		<bitfield name="FS_BUFFER" pos="8" type="boolean"/>
		<!-- set when both VS or FS in buffer mode: -->
		<bitfield name="INSTR_BUFFER" pos="10" type="boolean"/>
		<!-- TODO other bits probably matter when other stages active? -->
	</reg32>

	<bitset name="a4xx_sp_vs_fs_ctrl_reg0" inline="yes">
		<!--
			NOTE that SP_{VS,FS}_CTRL_REG1 are different, but so far REG0
			appears to be the same..
		-->
		<bitfield name="THREADMODE" pos="0" type="a3xx_threadmode"/>
		<!-- VARYING bit only for FS.. think it controls emitting (ei) flag? -->
		<bitfield name="VARYING" pos="1" type="boolean"/>
		<!-- maybe CACHEINVALID is two bits?? -->
		<bitfield name="CACHEINVALID" pos="2" type="boolean"/>
		<doc>
			The full/half register footprint is in units of four components,
			so if r0.x is used, that counts as all of r0.[xyzw] as used.
			There are separate full/half register footprint values as the
			full and half registers are independent (not overlapping).
			Presumably the thread scheduler hardware allocates the full/half
			register names from the actual physical register file and
			handles the register renaming.
		</doc>
		<bitfield name="HALFREGFOOTPRINT" low="4" high="9" type="uint"/>
		<bitfield name="FULLREGFOOTPRINT" low="10" high="17" type="uint"/>
		<!-- maybe INOUTREGOVERLAP is a bitflag? -->
		<bitfield name="INOUTREGOVERLAP" low="18" high="19" type="uint"/>
		<bitfield name="THREADSIZE" pos="20" type="a3xx_threadsize"/>
		<bitfield name="SUPERTHREADMODE" pos="21" type="boolean"/>
		<bitfield name="PIXLODENABLE" pos="22" type="boolean"/>
	</bitset>

	<reg32 offset="0x22c4" name="SP_VS_CTRL_REG0" type="a4xx_sp_vs_fs_ctrl_reg0"/>
	<reg32 offset="0x22c5" name="SP_VS_CTRL_REG1">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="INITIALOUTSTANDING" low="24" high="30" type="uint"/>
	</reg32>
	<reg32 offset="0x22c6" name="SP_VS_PARAM_REG">
		<bitfield name="POSREGID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="PSIZEREGID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="TOTALVSOUTVAR" low="20" high="31" type="uint"/>
	</reg32>
	<array offset="0x22c7" name="SP_VS_OUT" stride="1" length="16">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="8" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="9" high="12" type="hex"/>
			<bitfield name="B_REGID" low="16" high="24" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="25" high="28" type="hex"/>
		</reg32>
	</array>
	<array offset="0x22d8" name="SP_VS_VPC_DST" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<doc>
				These seem to be offsets for storage of the varyings.
				Always seems to start from 8, possibly loc 0 and 4
				are for gl_Position and gl_PointSize?
			</doc>
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>

	<reg32 offset="0x22e0" name="SP_VS_OBJ_OFFSET_REG">
		<!-- always 00000000: -->
		<doc>
			From register spec:
			SP_FS_OBJ_OFFSET_REG.CONSTOBJECTSTARTOFFSET [16:24]: Constant object
			start offset in on chip RAM,
			128bit aligned
		</doc>
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x22e1" name="SP_VS_OBJ_START"/>
	<reg32 offset="0x22e2" name="SP_VS_PVT_MEM_PARAM"/>"
	<reg32 offset="0x22e3" name="SP_VS_PVT_MEM_ADDR"/>
	<reg32 offset="0x22e5" name="SP_VS_LENGTH_REG" type="uint"/>
	<reg32 offset="0x22e8" name="SP_FS_CTRL_REG0" type="a4xx_sp_vs_fs_ctrl_reg0"/>
	<reg32 offset="0x22e9" name="SP_FS_CTRL_REG1">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="FACENESS" pos="19" type="boolean"/>
		<bitfield name="VARYING" pos="20" type="boolean"/>
		<bitfield name="FRAGCOORD" pos="21" type="boolean"/>
	</reg32>
	<reg32 offset="0x22ea" name="SP_FS_OBJ_OFFSET_REG">
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x22eb" name="SP_FS_OBJ_START"/>
	<reg32 offset="0x22ec" name="SP_FS_PVT_MEM_PARAM"/>"
	<reg32 offset="0x22ed" name="SP_FS_PVT_MEM_ADDR"/>
	<reg32 offset="0x22ef" name="SP_FS_LENGTH_REG" type="uint"/>
	<reg32 offset="0x22f0" name="SP_FS_OUTPUT_REG">
		<bitfield name="MRT" low="0" high="3" type="uint"/>
		<bitfield name="DEPTH_ENABLE" pos="7" type="boolean"/>
		<!-- TODO double check.. for now assume same as a3xx -->
		<bitfield name="DEPTH_REGID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="SAMPLEMASK_REGID" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<array offset="0x22f1" name="SP_FS_MRT" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<bitfield name="REGID" low="0" high="7" type="a3xx_regid"/>
			<bitfield name="HALF_PRECISION" pos="8" type="boolean"/>
			<bitfield name="MRTFORMAT" low="12" high="17" type="a4xx_color_fmt"/>
			<bitfield name="COLOR_SRGB" pos="18" type="boolean"/>
		</reg32>
	</array>
	<reg32 offset="0x2300" name="SP_CS_CTRL_REG0"/>
	<reg32 offset="0x2301" name="SP_CS_OBJ_OFFSET_REG"/>
	<reg32 offset="0x2302" name="SP_CS_OBJ_START"/>
	<reg32 offset="0x2303" name="SP_CS_PVT_MEM_PARAM"/>
	<reg32 offset="0x2304" name="SP_CS_PVT_MEM_ADDR"/>
	<reg32 offset="0x2305" name="SP_CS_PVT_MEM_SIZE"/>
	<reg32 offset="0x2306" name="SP_CS_LENGTH_REG" type="uint"/>
	<reg32 offset="0x230d" name="SP_HS_OBJ_OFFSET_REG">
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x230e" name="SP_HS_OBJ_START"/>
	<reg32 offset="0x230f" name="SP_HS_PVT_MEM_PARAM"/>"
	<reg32 offset="0x2310" name="SP_HS_PVT_MEM_ADDR"/>
	<reg32 offset="0x2312" name="SP_HS_LENGTH_REG" type="uint"/>

	<reg32 offset="0x231a" name="SP_DS_PARAM_REG">
		<bitfield name="POSREGID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="TOTALGSOUTVAR" low="20" high="31" type="uint"/>
	</reg32>
	<array offset="0x231b" name="SP_DS_OUT" stride="1" length="16">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="8" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="9" high="12" type="hex"/>
			<bitfield name="B_REGID" low="16" high="24" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="25" high="28" type="hex"/>
		</reg32>
	</array>
	<array offset="0x232c" name="SP_DS_VPC_DST" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<doc>
				These seem to be offsets for storage of the varyings.
				Always seems to start from 8, possibly loc 0 and 4
				are for gl_Position and gl_PointSize?
			</doc>
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>
	<reg32 offset="0x2334" name="SP_DS_OBJ_OFFSET_REG">
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2335" name="SP_DS_OBJ_START"/>
	<reg32 offset="0x2336" name="SP_DS_PVT_MEM_PARAM"/>"
	<reg32 offset="0x2337" name="SP_DS_PVT_MEM_ADDR"/>
	<reg32 offset="0x2339" name="SP_DS_LENGTH_REG" type="uint"/>

	<reg32 offset="0x2341" name="SP_GS_PARAM_REG">
		<bitfield name="POSREGID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="PRIMREGID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="TOTALGSOUTVAR" low="20" high="31" type="uint"/>
	</reg32>
	<array offset="0x2342" name="SP_GS_OUT" stride="1" length="16">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="8" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="9" high="12" type="hex"/>
			<bitfield name="B_REGID" low="16" high="24" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="25" high="28" type="hex"/>
		</reg32>
	</array>
	<array offset="0x2353" name="SP_GS_VPC_DST" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<doc>
				These seem to be offsets for storage of the varyings.
				Always seems to start from 8, possibly loc 0 and 4
				are for gl_Position and gl_PointSize?
			</doc>
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>
	<reg32 offset="0x235b" name="SP_GS_OBJ_OFFSET_REG">
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x235c" name="SP_GS_OBJ_START"/>
	<reg32 offset="0x235d" name="SP_GS_PVT_MEM_PARAM"/>"
	<reg32 offset="0x235e" name="SP_GS_PVT_MEM_ADDR"/>
	<reg32 offset="0x2360" name="SP_GS_LENGTH_REG" type="uint"/>

	<!-- VPC registers -->
	<reg32 offset="0x0e60" name="VPC_DEBUG_RAM_SEL"/>
	<reg32 offset="0x0e61" name="VPC_DEBUG_RAM_READ"/>
	<reg32 offset="0x0e64" name="VPC_DEBUG_ECO_CONTROL"/>
	<reg32 offset="0x0e68" name="VPC_PERFCTR_VPC_SEL_3"/>
	<reg32 offset="0x2140" name="VPC_ATTR">
		<bitfield name="TOTALATTR" low="0" high="8" type="uint"/>
		<!-- PSIZE bit set if gl_PointSize written: -->
		<bitfield name="PSIZE" pos="9" type="boolean"/>
		<bitfield name="THRDASSIGN" low="12" high="13" type="uint"/>
		<bitfield name="ENABLE" pos="25" type="boolean"/>
	</reg32>
	<reg32 offset="0x2141" name="VPC_PACK">
		<bitfield name="NUMBYPASSVAR" low="0" high="7" type="uint"/>
		<bitfield name="NUMFPNONPOSVAR" low="8" high="15" type="uint"/>
		<bitfield name="NUMNONPOSVSVAR" low="16" high="23" type="uint"/>
	</reg32>
	<array offset="0x2142" name="VPC_VARYING_INTERP" stride="1" length="8">
		<reg32 offset="0x0" name="MODE"/>
	</array>
	<array offset="0x214a" name="VPC_VARYING_PS_REPL" stride="1" length="8">
		<reg32 offset="0x0" name="MODE"/>
	</array>

	<reg32 offset="0x216e" name="VPC_SO_FLUSH_WADDR_3"/>

	<!-- VSC registers -->
	<reg32 offset="0x0c00" name="VSC_BIN_SIZE">
		<bitfield name="WIDTH" low="0" high="4" shr="5" type="uint"/>
		<bitfield name="HEIGHT" low="5" high="9" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x0c01" name="VSC_SIZE_ADDRESS"/>
	<reg32 offset="0x0c02" name="VSC_SIZE_ADDRESS2"/>
	<reg32 offset="0x0c03" name="VSC_DEBUG_ECO_CONTROL"/>
	<array offset="0x0c08" name="VSC_PIPE_CONFIG" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<doc>
				Configures the mapping between VSC_PIPE buffer and
				bin, X/Y specify the bin index in the horiz/vert
				direction (0,0 is upper left, 0,1 is leftmost bin
				on second row, and so on).  W/H specify the number
				of bins assigned to this VSC_PIPE in the horiz/vert
				dimension.
			</doc>
			<bitfield name="X" low="0" high="9" type="uint"/>
			<bitfield name="Y" low="10" high="19" type="uint"/>
			<bitfield name="W" low="20" high="23" type="uint"/>
			<bitfield name="H" low="24" high="27" type="uint"/>
		</reg32>
	</array>
	<array offset="0x0c10" name="VSC_PIPE_DATA_ADDRESS" stride="1" length="8">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<array offset="0x0c18" name="VSC_PIPE_DATA_LENGTH" stride="1" length="8">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<reg32 offset="0x0c41" name="VSC_PIPE_PARTIAL_POSN_1"/>
	<reg32 offset="0x0c50" name="VSC_PERFCTR_VSC_SEL_0"/>
	<reg32 offset="0x0c51" name="VSC_PERFCTR_VSC_SEL_1"/>

	<!-- VFD registers -->
	<reg32 offset="0x0e40" name="VFD_DEBUG_CONTROL"/>
	<reg32 offset="0x0e4a" name="VFD_PERFCTR_VFD_SEL_7"/>
	<reg32 offset="0x21d0" name="VGT_CL_INITIATOR"/>
	<reg32 offset="0x21d9" name="VGT_EVENT_INITIATOR"/>
	<reg32 offset="0x2200" name="VFD_CONTROL_0">
		<doc>
			TOTALATTRTOVS is # of attributes to vertex shader, in register
			slots (ie. vec4+vec3 -> 7)
		</doc>
		<bitfield name="TOTALATTRTOVS" low="0" high="7" type="uint"/>
		<doc>
		BYPASSATTROVS seems to count varyings that are just directly
		assigned from attributes (ie, "vFoo = aFoo;")
		</doc>
		<bitfield name="BYPASSATTROVS" low="9" high="16" type="uint"/>
		<doc>STRMDECINSTRCNT is # of VFD_DECODE_INSTR registers valid</doc>
		<bitfield name="STRMDECINSTRCNT" low="20" high="25" type="uint"/>
		<doc>STRMFETCHINSTRCNT is # of VFD_FETCH_INSTR registers valid</doc>
		<bitfield name="STRMFETCHINSTRCNT" low="26" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2201" name="VFD_CONTROL_1">
		<doc>MAXSTORAGE could be # of attributes/vbo's</doc>
		<bitfield name="MAXSTORAGE" low="0" high="15" type="uint"/>
		<bitfield name="REGID4VTX" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="REGID4INST" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0x2202" name="VFD_CONTROL_2"/>
	<reg32 offset="0x2203" name="VFD_CONTROL_3">
		<bitfield name="REGID_VTXCNT" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="REGID_TESSX" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="REGID_TESSY" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0x2204" name="VFD_CONTROL_4"/>
	<reg32 offset="0x2208" name="VFD_INDEX_OFFSET"/>
	<array offset="0x220a" name="VFD_FETCH" stride="4" length="32">
		<reg32 offset="0x0" name="INSTR_0">
			<bitfield name="FETCHSIZE" low="0" high="6" type="uint"/>
			<bitfield name="BUFSTRIDE" low="7" high="16" type="uint"/>
			<bitfield name="SWITCHNEXT" pos="19" type="boolean"/>
			<bitfield name="INSTANCED" pos="20" type="boolean"/>
		</reg32>
		<reg32 offset="0x1" name="INSTR_1"/>
		<reg32 offset="0x2" name="INSTR_2">
			<bitfield name="SIZE" low="4" high="31" shr="4"/>
		</reg32>
		<reg32 offset="0x3" name="INSTR_3">
			<!-- might well be bigger.. -->
			<bitfield name="STEPRATE" low="0" high="8" type="uint"/>
		</reg32>
	</array>
	<array offset="0x228a" name="VFD_DECODE" stride="1" length="32">
		<reg32 offset="0x0" name="INSTR">
			<bitfield name="WRITEMASK" low="0" high="3" type="hex"/>
			<!-- not sure if this is a bit flag and another flag above it, or?? -->
			<bitfield name="CONSTFILL" pos="4" type="boolean"/>
			<bitfield name="FORMAT" low="6" high="11" type="a4xx_vtx_fmt"/>
			<bitfield name="REGID" low="12" high="19" type="a3xx_regid"/>
			<bitfield name="INT" pos="20" type="boolean"/>
			<doc>SHIFTCNT appears to be size, ie. FLOAT_32_32_32 is 12, and BYTE_8 is 1</doc>
			<bitfield name="SWAP" low="22" high="23" type="a3xx_color_swap"/>
			<bitfield name="SHIFTCNT" low="24" high="28" type="uint"/>
			<bitfield name="LASTCOMPVALID" pos="29" type="boolean"/>
			<bitfield name="SWITCHNEXT" pos="30" type="boolean"/>
		</reg32>
	</array>

	<!-- TPL1 registers -->
	<reg32 offset="0x0f00" name="TPL1_DEBUG_ECO_CONTROL"/>
	<!-- always 0000003a: -->
	<reg32 offset="0x0f03" name="TPL1_TP_MODE_CONTROL"/>
	<reg32 offset="0x0f0b" name="TPL1_PERFCTR_TP_SEL_7"/>
	<reg32 offset="0x2380" name="TPL1_TP_TEX_OFFSET"/>
	<reg32 offset="0x2381" name="TPL1_TP_TEX_COUNT">
		<bitfield name="VS" low="0" high="7" type="uint"/>
		<bitfield name="HS" low="8" high="15" type="uint"/>
		<bitfield name="DS" low="16" high="23" type="uint"/>
		<bitfield name="GS" low="24" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2384" name="TPL1_TP_VS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x2387" name="TPL1_TP_HS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x238a" name="TPL1_TP_DS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x238d" name="TPL1_TP_GS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x23a0" name="TPL1_TP_FS_TEX_COUNT"/>
	<reg32 offset="0x23a1" name="TPL1_TP_FS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x23a4" name="TPL1_TP_CS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x23a5" name="TPL1_TP_CS_SAMPLER_BASE_ADDR"/>
	<reg32 offset="0x23a6" name="TPL1_TP_CS_TEXMEMOBJ_BASE_ADDR"/>

	<!-- GRAS registers -->
	<reg32 offset="0x0c80" name="GRAS_TSE_STATUS"/>
	<reg32 offset="0x0c81" name="GRAS_DEBUG_ECO_CONTROL"/>
	<reg32 offset="0x0c88" name="GRAS_PERFCTR_TSE_SEL_0"/>
	<reg32 offset="0x0c8b" name="GRAS_PERFCTR_TSE_SEL_3"/>
	<reg32 offset="0x2000" name="GRAS_CL_CLIP_CNTL">
		<bitfield name="CLIP_DISABLE" pos="15" type="boolean"/>
		<bitfield name="ZERO_GB_SCALE_Z" pos="22" type="boolean"/>
	</reg32>
	<reg32 offset="0x2003" name="GRAS_CLEAR_CNTL">
		<!-- probably not the right name, but.. -->
		<!-- bit0 set for everything *but* fastclear -->
		<bitfield name="NOT_FASTCLEAR" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x2004" name="GRAS_CL_GB_CLIP_ADJ">
		<bitfield name="HORZ" low="0" high="9" type="uint"/>
		<bitfield name="VERT" low="10" high="19" type="uint"/>
	</reg32>
	<reg32 offset="0x2008" name="GRAS_CL_VPORT_XOFFSET_0" type="float"/>
	<reg32 offset="0x2009" name="GRAS_CL_VPORT_XSCALE_0" type="float"/>
	<reg32 offset="0x200a" name="GRAS_CL_VPORT_YOFFSET_0" type="float"/>
	<reg32 offset="0x200b" name="GRAS_CL_VPORT_YSCALE_0" type="float"/>
	<reg32 offset="0x200c" name="GRAS_CL_VPORT_ZOFFSET_0" type="float"/>
	<reg32 offset="0x200d" name="GRAS_CL_VPORT_ZSCALE_0" type="float"/>
	<reg32 offset="0x2070" name="GRAS_SU_POINT_MINMAX">
		<bitfield name="MIN" low="0" high="15" type="ufixed" radix="4"/>
		<bitfield name="MAX" low="16" high="31" type="ufixed" radix="4"/>
	</reg32>
	<reg32 offset="0x2071" name="GRAS_SU_POINT_SIZE" type="fixed" radix="4"/>
	<reg32 offset="0x2073" name="GRAS_ALPHA_CONTROL">
		<bitfield name="ALPHA_TEST_ENABLE" pos="2" type="boolean"/>
	</reg32>
	<reg32 offset="0x2074" name="GRAS_SU_POLY_OFFSET_SCALE" type="float"/>
	<reg32 offset="0x2075" name="GRAS_SU_POLY_OFFSET_OFFSET" type="float"/>
	<reg32 offset="0x2076" name="GRAS_SU_POLY_OFFSET_CLAMP" type="float"/>
	<reg32 offset="0x2077" name="GRAS_DEPTH_CONTROL">
		<!-- guestimating that this is GRAS based on addr -->
		<bitfield name="FORMAT" low="0" high="1" type="a4xx_depth_format"/>
	</reg32>
	<reg32 offset="0x2078" name="GRAS_SU_MODE_CONTROL">
		<bitfield name="CULL_FRONT" pos="0" type="boolean"/>
		<bitfield name="CULL_BACK" pos="1" type="boolean"/>
		<bitfield name="FRONT_CW" pos="2" type="boolean"/>
		<bitfield name="LINEHALFWIDTH" low="3" high="10" radix="2" type="fixed"/>
		<bitfield name="POLY_OFFSET" pos="11" type="boolean"/>
		<!-- bit20 set whenever RENDER_MODE = RB_RENDERING_PASS -->
		<bitfield name="RENDERING_PASS" pos="20" type="boolean"/>
	</reg32>
	<reg32 offset="0x207b" name="GRAS_SC_CONTROL">
		<!-- complete wild-ass-guess for sizes of these bitfields.. -->
		<bitfield name="RENDER_MODE" low="2" high="3" type="a3xx_render_mode"/>
		<bitfield name="MSAA_SAMPLES" low="7" high="9" type="uint"/>
		<bitfield name="MSAA_DISABLE" pos="11" type="boolean"/>
		<bitfield name="RASTER_MODE" low="12" high="15"/>
	</reg32>
	<reg32 offset="0x207c" name="GRAS_SC_SCREEN_SCISSOR_TL" type="adreno_reg_xy"/>
	<reg32 offset="0x207d" name="GRAS_SC_SCREEN_SCISSOR_BR" type="adreno_reg_xy"/>
	<reg32 offset="0x209c" name="GRAS_SC_WINDOW_SCISSOR_BR" type="adreno_reg_xy"/>
	<reg32 offset="0x209d" name="GRAS_SC_WINDOW_SCISSOR_TL" type="adreno_reg_xy"/>
	<reg32 offset="0x209e" name="GRAS_SC_EXTENT_WINDOW_BR" type="adreno_reg_xy"/>
	<reg32 offset="0x209f" name="GRAS_SC_EXTENT_WINDOW_TL" type="adreno_reg_xy"/>

	<!-- UCHE registers -->
	<reg32 offset="0x0e80" name="UCHE_CACHE_MODE_CONTROL"/>
	<reg32 offset="0x0e83" name="UCHE_TRAP_BASE_LO"/>
	<reg32 offset="0x0e84" name="UCHE_TRAP_BASE_HI"/>
	<reg32 offset="0x0e88" name="UCHE_CACHE_STATUS"/>
	<reg32 offset="0x0e8a" name="UCHE_INVALIDATE0"/>
	<reg32 offset="0x0e8b" name="UCHE_INVALIDATE1"/>
	<reg32 offset="0x0e8c" name="UCHE_CACHE_WAYS_VFD"/>
	<reg32 offset="0x0e95" name="UCHE_PERFCTR_UCHE_SEL_7"/>

	<!-- HLSQ registers -->
	<reg32 offset="0x0e00" name="HLSQ_TIMEOUT_THRESHOLD"/>
	<reg32 offset="0x0e04" name="HLSQ_DEBUG_ECO_CONTROL"/>
	<!-- always 00000000: -->
	<reg32 offset="0x0e05" name="HLSQ_MODE_CONTROL"/>
	<reg32 offset="0x0e0e" name="HLSQ_PERF_PIPE_MASK"/>
	<reg32 offset="0x23c0" name="HLSQ_CONTROL_0_REG">
		<!-- I guess same as a3xx, but so far only seen 08000050 -->
		<bitfield name="FSTHREADSIZE" pos="4" type="a3xx_threadsize"/>
		<bitfield name="FSSUPERTHREADENABLE" pos="6" type="boolean"/>
		<bitfield name="SPSHADERRESTART" pos="9" type="boolean"/>
		<bitfield name="RESERVED2" pos="10" type="boolean"/>
		<bitfield name="CHUNKDISABLE" pos="26" type="boolean"/>
		<bitfield name="CONSTMODE" pos="27" type="uint"/>
		<bitfield name="LAZYUPDATEDISABLE" pos="28" type="boolean"/>
		<bitfield name="SPCONSTFULLUPDATE" pos="29" type="boolean"/>
		<bitfield name="TPFULLUPDATE" pos="30" type="boolean"/>
		<bitfield name="SINGLECONTEXT" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x23c1" name="HLSQ_CONTROL_1_REG">
		<bitfield name="VSTHREADSIZE" pos="6" type="a3xx_threadsize"/>
		<bitfield name="VSSUPERTHREADENABLE" pos="8" type="boolean"/>
		<bitfield name="RESERVED1" pos="9" type="boolean"/>
		<bitfield name="COORDREGID" low="16" high="23" type="a3xx_regid"/>
		<!-- set if gl_FragCoord.[zw] used in frag shader: -->
		<bitfield name="ZWCOORDREGID" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0x23c2" name="HLSQ_CONTROL_2_REG">
		<bitfield name="PRIMALLOCTHRESHOLD" low="26" high="31" type="uint"/>
		<bitfield name="FACEREGID" low="2" high="9" type="a3xx_regid"/>
		<bitfield name="SAMPLEID_REGID" low="10" high="17" type="a3xx_regid"/>
		<bitfield name="SAMPLEMASK_REGID" low="18" high="25" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0x23c3" name="HLSQ_CONTROL_3_REG">
		<!-- register loaded with position (bary.f, gl_FragCoord, etc) -->
		<bitfield name="REGID" low="0" high="7" type="a3xx_regid"/>
	</reg32>
	<!-- 0x23c4 3 regids, lowest one goes to 0 when *not* per-sample shading -->
	<reg32 offset="0x23c4" name="HLSQ_CONTROL_4_REG"/>

	<!-- TODO probably a bitset for HLSQ_*S_CONTROL.. -->
	<reg32 offset="0x23c5" name="HLSQ_VS_CONTROL_REG">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="CONSTOBJECTOFFSET" low="8" high="15" type="uint"/>
		<bitfield name="ENABLED" pos="16"/>
		<bitfield name="SHADEROBJOFFSET" low="17" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x23c6" name="HLSQ_FS_CONTROL_REG">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="CONSTOBJECTOFFSET" low="8" high="15" type="uint"/>
		<bitfield name="ENABLED" pos="16"/>
		<bitfield name="SHADEROBJOFFSET" low="17" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</reg32>
	<!-- not quite sure the order of the remainder, so order of hull/domain/geom yet -->
	<reg32 offset="0x23c7" name="HLSQ_HS_CONTROL_REG">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="CONSTOBJECTOFFSET" low="8" high="15" type="uint"/>
		<bitfield name="ENABLED" pos="16"/>
		<bitfield name="SHADEROBJOFFSET" low="17" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x23c8" name="HLSQ_DS_CONTROL_REG">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="CONSTOBJECTOFFSET" low="8" high="15" type="uint"/>
		<bitfield name="ENABLED" pos="16"/>
		<bitfield name="SHADEROBJOFFSET" low="17" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x23c9" name="HLSQ_GS_CONTROL_REG">
		<bitfield name="CONSTLENGTH" low="0" high="7" type="uint"/>
		<bitfield name="CONSTOBJECTOFFSET" low="8" high="15" type="uint"/>
		<bitfield name="ENABLED" pos="16"/>
		<bitfield name="SHADEROBJOFFSET" low="17" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x23ca" name="HLSQ_CS_CONTROL"/>
	<reg32 offset="0x23cd" name="HLSQ_CL_NDRANGE_0"/>
	<reg32 offset="0x23ce" name="HLSQ_CL_NDRANGE_1"/>
	<reg32 offset="0x23cf" name="HLSQ_CL_NDRANGE_2"/>
	<reg32 offset="0x23d0" name="HLSQ_CL_NDRANGE_3"/>
	<reg32 offset="0x23d1" name="HLSQ_CL_NDRANGE_4"/>
	<reg32 offset="0x23d2" name="HLSQ_CL_NDRANGE_5"/>
	<reg32 offset="0x23d3" name="HLSQ_CL_NDRANGE_6"/>
	<reg32 offset="0x23d4" name="HLSQ_CL_CONTROL_0"/>
	<reg32 offset="0x23d5" name="HLSQ_CL_CONTROL_1"/>
	<reg32 offset="0x23d6" name="HLSQ_CL_KERNEL_CONST"/>
	<reg32 offset="0x23d7" name="HLSQ_CL_KERNEL_GROUP_X"/>
	<reg32 offset="0x23d8" name="HLSQ_CL_KERNEL_GROUP_Y"/>
	<reg32 offset="0x23d9" name="HLSQ_CL_KERNEL_GROUP_Z"/>
	<reg32 offset="0x23da" name="HLSQ_CL_WG_OFFSET"/>
	<reg32 offset="0x23db" name="HLSQ_UPDATE_CONTROL"/>

	<!-- PC registers -->
	<reg32 offset="0x0d00" name="PC_BINNING_COMMAND">
		<bitfield name="BINNING_ENABLE" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x0d0c" name="PC_DRAWCALL_SETUP_OVERRIDE"/>
	<reg32 offset="0x0d10" name="PC_PERFCTR_PC_SEL_0"/>
	<reg32 offset="0x0d17" name="PC_PERFCTR_PC_SEL_7"/>
	<reg32 offset="0x21c0" name="PC_BIN_BASE"/>
	<reg32 offset="0x21c4" name="PC_PRIM_VTX_CNTL">
		<!-- bit0 set if there is >= 1 varying (actually used by FS) -->
		<bitfield name="VAROUT" low="0" high="3" type="uint">
			<doc>in groups of 4x vec4, blob only uses values
			0, 1, 2, 4, 6, 8</doc>
		</bitfield>
		<bitfield name="PRIMITIVE_RESTART" pos="20" type="boolean"/>
		<bitfield name="PROVOKING_VTX_LAST" pos="25" type="boolean"/>
		<!-- PSIZE bit set if gl_PointSize written: -->
		<bitfield name="PSIZE" pos="26" type="boolean"/>
	</reg32>
	<reg32 offset="0x21c5" name="UNKNOWN_21C5"/>
	<reg32 offset="0x21c6" name="PC_RESTART_INDEX"/>
	<reg32 offset="0x21e5" name="PC_GS_PARAM">
		<bitfield name="MAX_VERTICES" low="0" high="9" type="uint"/><!-- +1, i.e. max is 1024 -->
		<bitfield name="INVOCATIONS" low="11" high="15" type="uint"/><!-- +1, i.e. max is 32 -->
		<bitfield name="PRIMTYPE" low="23" high="24" type="adreno_pa_su_sc_draw"/>
		<bitfield name="LAYER" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x21e7" name="PC_HS_PARAM">
		<bitfield name="VERTICES_OUT" low="0" high="5" type="uint"/>
		<bitfield name="SPACING" low="21" high="22" type="a4xx_tess_spacing"/>
		<bitfield name="PRIMTYPE" low="23" high="24" type="adreno_pa_su_sc_draw"/>
	</reg32>

	<!-- VBIF registers -->
	<reg32 offset="0x3000" name="VBIF_VERSION"/>
	<reg32 offset="0x3001" name="VBIF_CLKON">
		<bitfield name="FORCE_ON_TESTBUS" pos="0" type="boolean"/>
	</reg32>
	<reg32 offset="0x301c" name="VBIF_ABIT_SORT"/>
	<reg32 offset="0x301d" name="VBIF_ABIT_SORT_CONF"/>
	<reg32 offset="0x302a" name="VBIF_GATE_OFF_WRREQ_EN"/>
	<reg32 offset="0x302c" name="VBIF_IN_RD_LIM_CONF0"/>
	<reg32 offset="0x302d" name="VBIF_IN_RD_LIM_CONF1"/>
	<reg32 offset="0x3030" name="VBIF_IN_WR_LIM_CONF0"/>
	<reg32 offset="0x3031" name="VBIF_IN_WR_LIM_CONF1"/>
	<reg32 offset="0x3049" name="VBIF_ROUND_ROBIN_QOS_ARB"/>

	<!--
	Unknown registers:
	(mostly related to DX11 features not used yet, I guess?)
	-->

	<!-- always 00000006: -->
	<reg32 offset="0x0cc5" name="UNKNOWN_0CC5"/>

	<!-- always 00000000: -->
	<reg32 offset="0x0cc6" name="UNKNOWN_0CC6"/>

	<!-- always 00000001: -->
	<reg32 offset="0x0d01" name="UNKNOWN_0D01"/>

	<!-- always 00000000: -->
	<reg32 offset="0x0e42" name="UNKNOWN_0E42"/>

	<!-- always 00040000: -->
	<reg32 offset="0x0ec2" name="UNKNOWN_0EC2"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2001" name="UNKNOWN_2001"/>

	<!-- always 00000000: -->
	<reg32 offset="0x209b" name="UNKNOWN_209B"/>

	<!-- always 00000000: -->
	<reg32 offset="0x20ef" name="UNKNOWN_20EF"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2152" name="UNKNOWN_2152"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2153" name="UNKNOWN_2153"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2154" name="UNKNOWN_2154"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2155" name="UNKNOWN_2155"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2156" name="UNKNOWN_2156"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2157" name="UNKNOWN_2157"/>

	<!-- always 0000000b: -->
	<reg32 offset="0x21c3" name="UNKNOWN_21C3"/>

	<!-- always 00000001: -->
	<reg32 offset="0x21e6" name="UNKNOWN_21E6"/>

	<!-- always 00000000: -->
	<reg32 offset="0x2209" name="UNKNOWN_2209"/>

	<!-- always 00000000: -->
	<reg32 offset="0x22d7" name="UNKNOWN_22D7"/>

        <!-- always 00fcfc00: -->
        <reg32 offset="0x2352" name="UNKNOWN_2352"/>

</domain>


<domain name="A4XX_TEX_SAMP" width="32">
	<doc>Texture sampler dwords</doc>
	<enum name="a4xx_tex_filter">
		<value name="A4XX_TEX_NEAREST" value="0"/>
		<value name="A4XX_TEX_LINEAR" value="1"/>
		<value name="A4XX_TEX_ANISO" value="2"/>
	</enum>
	<enum name="a4xx_tex_clamp">
		<value name="A4XX_TEX_REPEAT" value="0"/>
		<value name="A4XX_TEX_CLAMP_TO_EDGE" value="1"/>
		<value name="A4XX_TEX_MIRROR_REPEAT" value="2"/>
		<value name="A4XX_TEX_CLAMP_TO_BORDER" value="3"/>
		<value name="A4XX_TEX_MIRROR_CLAMP" value="4"/>
	</enum>
	<enum name="a4xx_tex_aniso">
		<value name="A4XX_TEX_ANISO_1" value="0"/>
		<value name="A4XX_TEX_ANISO_2" value="1"/>
		<value name="A4XX_TEX_ANISO_4" value="2"/>
		<value name="A4XX_TEX_ANISO_8" value="3"/>
		<value name="A4XX_TEX_ANISO_16" value="4"/>
	</enum>
	<reg32 offset="0" name="0">
		<bitfield name="MIPFILTER_LINEAR_NEAR" pos="0" type="boolean"/>
		<bitfield name="XY_MAG" low="1" high="2" type="a4xx_tex_filter"/>
		<bitfield name="XY_MIN" low="3" high="4" type="a4xx_tex_filter"/>
		<bitfield name="WRAP_S" low="5" high="7" type="a4xx_tex_clamp"/>
		<bitfield name="WRAP_T" low="8" high="10" type="a4xx_tex_clamp"/>
		<bitfield name="WRAP_R" low="11" high="13" type="a4xx_tex_clamp"/>
		<bitfield name="ANISO" low="14" high="16" type="a4xx_tex_aniso"/>
		<bitfield name="LOD_BIAS" low="19" high="31" type="fixed" radix="8"/><!-- no idea how many bits for real -->
	</reg32>
	<reg32 offset="1" name="1">
		<bitfield name="COMPARE_FUNC" low="1" high="3" type="adreno_compare_func"/>
		<bitfield name="CUBEMAPSEAMLESSFILTOFF" pos="4" type="boolean"/>
		<bitfield name="UNNORM_COORDS" pos="5" type="boolean"/>
		<bitfield name="MIPFILTER_LINEAR_FAR" pos="6" type="boolean"/>
		<bitfield name="MAX_LOD" low="8" high="19" type="ufixed" radix="8"/>
		<bitfield name="MIN_LOD" low="20" high="31" type="ufixed" radix="8"/>
	</reg32>
</domain>

<domain name="A4XX_TEX_CONST" width="32">
	<doc>Texture constant dwords</doc>
	<enum name="a4xx_tex_swiz">
		<!-- same as a2xx? -->
		<value name="A4XX_TEX_X" value="0"/>
		<value name="A4XX_TEX_Y" value="1"/>
		<value name="A4XX_TEX_Z" value="2"/>
		<value name="A4XX_TEX_W" value="3"/>
		<value name="A4XX_TEX_ZERO" value="4"/>
		<value name="A4XX_TEX_ONE" value="5"/>
	</enum>
	<enum name="a4xx_tex_type">
		<value name="A4XX_TEX_1D" value="0"/>
		<value name="A4XX_TEX_2D" value="1"/>
		<value name="A4XX_TEX_CUBE" value="2"/>
		<value name="A4XX_TEX_3D" value="3"/>
	</enum>
	<reg32 offset="0" name="0">
		<bitfield name="TILED" pos="0" type="boolean"/>
		<bitfield name="SRGB" pos="2" type="boolean"/>
		<bitfield name="SWIZ_X" low="4" high="6" type="a4xx_tex_swiz"/>
		<bitfield name="SWIZ_Y" low="7" high="9" type="a4xx_tex_swiz"/>
		<bitfield name="SWIZ_Z" low="10" high="12" type="a4xx_tex_swiz"/>
		<bitfield name="SWIZ_W" low="13" high="15" type="a4xx_tex_swiz"/>
		<bitfield name="MIPLVLS" low="16" high="19" type="uint"/>
		<bitfield name="FMT" low="22" high="28" type="a4xx_tex_fmt"/>
		<bitfield name="TYPE" low="29" high="30" type="a4xx_tex_type"/>
	</reg32>
	<reg32 offset="1" name="1">
		<bitfield name="HEIGHT" low="0" high="14" type="uint"/>
		<bitfield name="WIDTH" low="15" high="28" type="uint"/>
	</reg32>
	<reg32 offset="2" name="2">
		<bitfield name="FETCHSIZE" low="0" high="3" type="a4xx_tex_fetchsize"/>
		<doc>Pitch in bytes (so actually stride)</doc>
		<bitfield name="PITCH" low="9" high="29" type="uint"/>
		<bitfield name="SWAP" low="30" high="31" type="a3xx_color_swap"/>
	</reg32>
	<reg32 offset="3" name="3">
		<bitfield name="LAYERSZ" low="0" high="13" shr="12" type="uint"/>
		<bitfield name="DEPTH" low="18" high="30" type="uint"/>
	</reg32>
	<reg32 offset="4" name="4">
		<!--
		like a3xx we seem to have two LAYERSZ's.. although this one
		seems too small to be useful, and when it overflows blob just
		sets it to zero..
		 -->
		<bitfield name="LAYERSZ" low="0" high="3" shr="12" type="uint"/>
		<bitfield name="BASE" low="5" high="31" shr="5"/>
	</reg32>
	<reg32 offset="5" name="5"/>
	<reg32 offset="6" name="6"/>
	<reg32 offset="7" name="7"/>
</domain>

</database>

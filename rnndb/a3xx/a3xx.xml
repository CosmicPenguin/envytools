<?xml version="1.0" encoding="UTF-8"?>
<database xmlns="http://nouveau.freedesktop.org/"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://nouveau.freedesktop.org/ rules-ng.xsd">
<import file="freedreno_copyright.xml"/>
<import file="adreno_common.xml"/>
<import file="adreno_pm4.xml"/>

<enum name="a3xx_render_mode">
	<value name="RB_RENDERING_PASS" value="0"/>
	<value name="RB_TILING_PASS" value="1"/>
	<value name="RB_RESOLVE_PASS" value="2"/>
</enum>

<enum name="a3xx_tile_mode">
	<value name="LINEAR" value="0"/>
	<value name="TILE_32X32" value="2"/>
</enum>

<enum name="a3xx_threadmode">
	<value value="0" name="MULTI"/>
	<value value="1" name="SINGLE"/>
</enum>

<enum name="a3xx_instrbuffermode">
	<value value="1" name="BUFFER"/>
</enum>

<enum name="a3xx_threadsize">
	<value value="0" name="TWO_QUADS"/>
	<value value="1" name="FOUR_QUADS"/>
</enum>

<enum name="a3xx_state_block_id">
	<value name="HLSQ_BLOCK_ID_TP_TEX" value="2"/>
	<value name="HLSQ_BLOCK_ID_TP_MIPMAP" value="3"/>
	<value name="HLSQ_BLOCK_ID_SP_VS" value="4"/>
	<value name="HLSQ_BLOCK_ID_SP_FS" value="6"/>
</enum>

<enum name="a3xx_cache_opcode">
	<value name="INVALIDATE" value="1"/>
</enum>

<enum name="a3xx_vtx_fmt">
	<value name="VFMT_FLOAT_32" value="0x0"/>
	<value name="VFMT_FLOAT_32_32" value="0x1"/>
	<value name="VFMT_FLOAT_32_32_32" value="0x2"/>
	<value name="VFMT_FLOAT_32_32_32_32" value="0x3"/>

	<value name="VFMT_FLOAT_16" value="0x4"/>
	<value name="VFMT_FLOAT_16_16" value="0x5"/>
	<value name="VFMT_FLOAT_16_16_16" value="0x6"/>
	<value name="VFMT_FLOAT_16_16_16_16" value="0x7"/>

	<value name="VFMT_FIXED_32" value="0x8"/>
	<value name="VFMT_FIXED_32_32" value="0x9"/>
	<value name="VFMT_FIXED_32_32_32" value="0xa"/>
	<value name="VFMT_FIXED_32_32_32_32" value="0xb"/>

	<value name="VFMT_SHORT_16" value="0x10"/>
	<value name="VFMT_SHORT_16_16" value="0x11"/>
	<value name="VFMT_SHORT_16_16_16" value="0x12"/>
	<value name="VFMT_SHORT_16_16_16_16" value="0x13"/>
	<value name="VFMT_USHORT_16" value="0x14"/>
	<value name="VFMT_USHORT_16_16" value="0x15"/>
	<value name="VFMT_USHORT_16_16_16" value="0x16"/>
	<value name="VFMT_USHORT_16_16_16_16" value="0x17"/>
	<value name="VFMT_NORM_SHORT_16" value="0x18"/>
	<value name="VFMT_NORM_SHORT_16_16" value="0x19"/>
	<value name="VFMT_NORM_SHORT_16_16_16" value="0x1a"/>
	<value name="VFMT_NORM_SHORT_16_16_16_16" value="0x1b"/>
	<value name="VFMT_NORM_USHORT_16" value="0x1c"/>
	<value name="VFMT_NORM_USHORT_16_16" value="0x1d"/>
	<value name="VFMT_NORM_USHORT_16_16_16" value="0x1e"/>
	<value name="VFMT_NORM_USHORT_16_16_16_16" value="0x1f"/>

	<value name="VFMT_UBYTE_8" value="0x28"/>
	<value name="VFMT_UBYTE_8_8" value="0x29"/>
	<value name="VFMT_UBYTE_8_8_8" value="0x2a"/>
	<value name="VFMT_UBYTE_8_8_8_8" value="0x2b"/>
	<value name="VFMT_NORM_UBYTE_8" value="0x2c"/>
	<value name="VFMT_NORM_UBYTE_8_8" value="0x2d"/>
	<value name="VFMT_NORM_UBYTE_8_8_8" value="0x2e"/>
	<value name="VFMT_NORM_UBYTE_8_8_8_8" value="0x2f"/>
	<value name="VFMT_BYTE_8" value="0x30"/>
	<value name="VFMT_BYTE_8_8" value="0x31"/>
	<value name="VFMT_BYTE_8_8_8" value="0x32"/>
	<value name="VFMT_BYTE_8_8_8_8" value="0x33"/>
	<value name="VFMT_NORM_BYTE_8" value="0x34"/>
	<value name="VFMT_NORM_BYTE_8_8" value="0x35"/>
	<value name="VFMT_NORM_BYTE_8_8_8" value="0x36"/>
	<value name="VFMT_NORM_BYTE_8_8_8_8" value="0x37"/>

	<!-- note: these also have bit 22 set in VFD_DECODE -->
	<value name="VFMT_UINT_10_10_10_2" value="0x3c"/>
	<value name="VFMT_NORM_UINT_10_10_10_2" value="0x3d"/>
	<value name="VFMT_INT_10_10_10_2" value="0x3e"/>
	<value name="VFMT_NORM_INT_10_10_10_2" value="0x3f"/>
</enum>

<enum name="a3xx_tex_fmt">
	<value name="TFMT_NORM_USHORT_565" value="0x4"/>
	<value name="TFMT_NORM_USHORT_5551" value="0x6"/>
	<value name="TFMT_NORM_USHORT_4444" value="0x7"/>
	<value name="TFMT_NORM_UINT_X8Z24" value="0xa"/>

	<!--
		YUV formats.. the different Y plane formats (ie. NV12 vs I420)
		should really be the same thing.  Ie. it is just a bunch of Y
		values in both cases.  But I guess the different values tell
		the hw what to do with the next 2 texture samplers, since the
		blob driver appears to setup 3 texture samplers for I420, NV12,
		and NV21
	 -->
	<value name="TFMT_NORM_UINT_NV12_UV_TILED" value="0x11"/>
	<value name="TFMT_NORM_UINT_NV12_Y_TILED" value="0x13"/>
	<value name="TFMT_NORM_UINT_NV12_UV" value="0x15"/>
	<value name="TFMT_NORM_UINT_NV12_Y" value="0x17"/>
	<value name="TFMT_NORM_UINT_I420_Y" value="0x18"/>
	<value name="TFMT_NORM_UINT_I420_U" value="0x1a"/>
	<value name="TFMT_NORM_UINT_I420_V" value="0x1b"/>

	<value name="TFMT_NORM_UINT_2_10_10_10" value="0x29"/>
	<value name="TFMT_NORM_UINT_A8" value="0x2c"/>    <!-- GL_ALPHA -->
	<value name="TFMT_NORM_UINT_L8_A8" value="0x2f"/> <!-- GL_LUMINANCE_ALPHA -->

	<!--
		NOTE: GL_ALPHA and GL_LUMINANCE_ALPHA aren't handled in a similar way
		to float16, float32.. but they seem to use non-standard swizzle too..
		perhaps we can ditch that if the pattern follows of 0xn0, 0xn1, 0xn2,
		0xn3 for 1, 2, 3, 4 components respectively..

		Only formats filled in below are the ones that have been observed by
		the blob or tested.. you can guess what the missing ones are..
	 -->

	<value name="TFMT_NORM_UINT_8" value="0x30"/>     <!-- GL_LUMINANCE -->
	<value name="TFMT_NORM_UINT_8_8" value="0x31"/>
	<value name="TFMT_NORM_UINT_8_8_8" value="0x32"/>
	<value name="TFMT_NORM_UINT_8_8_8_8" value="0x33"/>

	<value name="TFMT_FLOAT_16" value="0x40"/>
	<value name="TFMT_FLOAT_16_16" value="0x41"/>
	<!-- TFMT_FLOAT_16_16_16 -->
	<value name="TFMT_FLOAT_16_16_16_16" value="0x43"/>

	<value name="TFMT_FLOAT_32" value="0x54"/>
	<value name="TFMT_FLOAT_32_32" value="0x55"/>
	<!-- TFMT_FLOAT_32_32_32 -->
	<value name="TFMT_FLOAT_32_32_32_32" value="0x57"/>
</enum>

<enum name="a3xx_tex_fetchsize">
	<doc>
		Size pixel to fetch, in bytes.  Doesn't seem to be required, setting
		it to 0x0 seems to work ok, but may be less optimal.
	</doc>
	<value name="TFETCH_DISABLE" value="0"/>
	<value name="TFETCH_1_BYTE"  value="1"/>
	<value name="TFETCH_2_BYTE"  value="2"/>
	<value name="TFETCH_4_BYTE"  value="3"/>
	<value name="TFETCH_8_BYTE"  value="4"/>
	<value name="TFETCH_16_BYTE" value="5"/>
</enum>

<enum name="a3xx_color_fmt">
	<value name="RB_R8G8B8_UNORM" value="4"/>
	<value name="RB_R8G8B8A8_UNORM" value="8"/>
	<value name="RB_Z16_UNORM" value="12"/>
	<value name="RB_A8_UNORM" value="20"/>
</enum>

<enum name="a3xx_color_swap">
	<value name="WZYX" value="0"/>
	<value name="WXYZ" value="1"/>
	<value name="ZYXW" value="2"/>
	<value name="XYZW" value="3"/>
</enum>

<enum name="a3xx_msaa_samples">
	<value name="MSAA_ONE" value="0"/>
	<value name="MSAA_TWO" value="1"/>
	<value name="MSAA_FOUR" value="2"/>
</enum>

<enum name="a3xx_sp_perfcounter_select">
	<value name="SP_FS_CFLOW_INSTRUCTIONS" value="0x0c"/>
	<value name="SP_FS_FULL_ALU_INSTRUCTIONS" value="0x0e"/>
	<value name="SP0_ICL1_MISSES" value="0x1a"/>
	<value name="SP_ALU_ACTIVE_CYCLES" value="0x1d"/>
</enum>

<domain name="A3XX" width="32">
	<!-- RBBM registers -->
	<reg32 offset="0x0000" name="RBBM_HW_VERSION"/>
	<reg32 offset="0x0001" name="RBBM_HW_RELEASE"/>
	<reg32 offset="0x0002" name="RBBM_HW_CONFIGURATION"/>
	<reg32 offset="0x0010" name="RBBM_CLOCK_CTL"/>
	<reg32 offset="0x0012" name="RBBM_SP_HYST_CNT"/>
	<reg32 offset="0x0018" name="RBBM_SW_RESET_CMD"/>
	<reg32 offset="0x0020" name="RBBM_AHB_CTL0"/>
	<reg32 offset="0x0021" name="RBBM_AHB_CTL1"/>
	<reg32 offset="0x0022" name="RBBM_AHB_CMD"/>
	<reg32 offset="0x0027" name="RBBM_AHB_ERROR_STATUS"/>
	<reg32 offset="0x002e" name="RBBM_GPR0_CTL"/>
	<reg32 offset="0x0030" name="RBBM_STATUS">
		<bitfield name="HI_BUSY" pos="0" type="boolean"/>
		<bitfield name="CP_ME_BUSY" pos="1" type="boolean"/>
		<bitfield name="CP_PFP_BUSY" pos="2" type="boolean"/>
		<bitfield name="CP_NRT_BUSY" pos="14" type="boolean"/>
		<bitfield name="VBIF_BUSY" pos="15" type="boolean"/>
		<bitfield name="TSE_BUSY" pos="16" type="boolean"/>
		<bitfield name="RAS_BUSY" pos="17" type="boolean"/>
		<bitfield name="RB_BUSY" pos="18" type="boolean"/>
		<bitfield name="PC_DCALL_BUSY" pos="19" type="boolean"/>
		<bitfield name="PC_VSD_BUSY" pos="20" type="boolean"/>
		<bitfield name="VFD_BUSY" pos="21" type="boolean"/>
		<bitfield name="VPC_BUSY" pos="22" type="boolean"/>
		<bitfield name="UCHE_BUSY" pos="23" type="boolean"/>
		<bitfield name="SP_BUSY" pos="24" type="boolean"/>
		<bitfield name="TPL1_BUSY" pos="25" type="boolean"/>
		<bitfield name="MARB_BUSY" pos="26" type="boolean"/>
		<bitfield name="VSC_BUSY" pos="27" type="boolean"/>
		<bitfield name="ARB_BUSY" pos="28" type="boolean"/>
		<bitfield name="HLSQ_BUSY" pos="29" type="boolean"/>
		<bitfield name="GPU_BUSY_NOHC" pos="30" type="boolean"/>
		<bitfield name="GPU_BUSY" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x0033" name="RBBM_WAIT_IDLE_CLOCKS_CTL"/>
	<reg32 offset="0x0050" name="RBBM_INTERFACE_HANG_INT_CTL"/>
	<reg32 offset="0x0051" name="RBBM_INTERFACE_HANG_MASK_CTL0"/>
	<reg32 offset="0x0054" name="RBBM_INTERFACE_HANG_MASK_CTL1"/>
	<reg32 offset="0x0057" name="RBBM_INTERFACE_HANG_MASK_CTL2"/>
	<reg32 offset="0x005a" name="RBBM_INTERFACE_HANG_MASK_CTL3"/>

	<bitset name="A3XX_INT0">
		<bitfield name="RBBM_GPU_IDLE" pos="0"/>
		<bitfield name="RBBM_AHB_ERROR" pos="1"/>
		<bitfield name="RBBM_REG_TIMEOUT" pos="2"/>
		<bitfield name="RBBM_ME_MS_TIMEOUT" pos="3"/>
		<bitfield name="RBBM_PFP_MS_TIMEOUT" pos="4"/>
		<bitfield name="RBBM_ATB_BUS_OVERFLOW" pos="5"/>
		<bitfield name="VFD_ERROR" pos="6"/>
		<bitfield name="CP_SW_INT" pos="7"/>
		<bitfield name="CP_T0_PACKET_IN_IB" pos="8"/>
		<bitfield name="CP_OPCODE_ERROR" pos="9"/>
		<bitfield name="CP_RESERVED_BIT_ERROR" pos="10"/>
		<bitfield name="CP_HW_FAULT" pos="11"/>
		<bitfield name="CP_DMA" pos="12"/>
		<bitfield name="CP_IB2_INT" pos="13"/>
		<bitfield name="CP_IB1_INT" pos="14"/>
		<bitfield name="CP_RB_INT" pos="15"/>
		<bitfield name="CP_REG_PROTECT_FAULT" pos="16"/>
		<bitfield name="CP_RB_DONE_TS" pos="17"/>
		<bitfield name="CP_VS_DONE_TS" pos="18"/>
		<bitfield name="CP_PS_DONE_TS" pos="19"/>
		<bitfield name="CACHE_FLUSH_TS" pos="20"/>
		<bitfield name="CP_AHB_ERROR_HALT" pos="21"/>
		<bitfield name="MISC_HANG_DETECT" pos="24"/>
		<bitfield name="UCHE_OOB_ACCESS" pos="25"/>
	</bitset>

	<reg32 offset="0x0061" name="RBBM_INT_CLEAR_CMD" type="A3XX_INT0"/>
	<reg32 offset="0x0063" name="RBBM_INT_0_MASK" type="A3XX_INT0"/>
	<reg32 offset="0x0064" name="RBBM_INT_0_STATUS" type="A3XX_INT0"/>
	<reg32 offset="0x0080" name="RBBM_PERFCTR_CTL"/>
	<reg32 offset="0x0081" name="RBBM_PERFCTR_LOAD_CMD0"/>
	<reg32 offset="0x0082" name="RBBM_PERFCTR_LOAD_CMD1"/>
	<reg32 offset="0x0084" name="RBBM_PERFCTR_LOAD_VALUE_LO"/>
	<reg32 offset="0x0085" name="RBBM_PERFCTR_LOAD_VALUE_HI"/>
	<reg32 offset="0x0086" name="RBBM_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0087" name="RBBM_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0088" name="RBBM_GPU_BUSY_MASKED"/>
	<reg32 offset="0x0090" name="RBBM_PERFCTR_CP_0_LO"/>
	<reg32 offset="0x0091" name="RBBM_PERFCTR_CP_0_HI"/>
	<reg32 offset="0x0092" name="RBBM_PERFCTR_RBBM_0_LO"/>
	<reg32 offset="0x0093" name="RBBM_PERFCTR_RBBM_0_HI"/>
	<reg32 offset="0x0094" name="RBBM_PERFCTR_RBBM_1_LO"/>
	<reg32 offset="0x0095" name="RBBM_PERFCTR_RBBM_1_HI"/>
	<reg32 offset="0x0096" name="RBBM_PERFCTR_PC_0_LO"/>
	<reg32 offset="0x0097" name="RBBM_PERFCTR_PC_0_HI"/>
	<reg32 offset="0x0098" name="RBBM_PERFCTR_PC_1_LO"/>
	<reg32 offset="0x0099" name="RBBM_PERFCTR_PC_1_HI"/>
	<reg32 offset="0x009a" name="RBBM_PERFCTR_PC_2_LO"/>
	<reg32 offset="0x009b" name="RBBM_PERFCTR_PC_2_HI"/>
	<reg32 offset="0x009c" name="RBBM_PERFCTR_PC_3_LO"/>
	<reg32 offset="0x009d" name="RBBM_PERFCTR_PC_3_HI"/>
	<reg32 offset="0x009e" name="RBBM_PERFCTR_VFD_0_LO"/>
	<reg32 offset="0x009f" name="RBBM_PERFCTR_VFD_0_HI"/>
	<reg32 offset="0x00a0" name="RBBM_PERFCTR_VFD_1_LO"/>
	<reg32 offset="0x00a1" name="RBBM_PERFCTR_VFD_1_HI"/>
	<reg32 offset="0x00a2" name="RBBM_PERFCTR_HLSQ_0_LO"/>
	<reg32 offset="0x00a3" name="RBBM_PERFCTR_HLSQ_0_HI"/>
	<reg32 offset="0x00a4" name="RBBM_PERFCTR_HLSQ_1_LO"/>
	<reg32 offset="0x00a5" name="RBBM_PERFCTR_HLSQ_1_HI"/>
	<reg32 offset="0x00a6" name="RBBM_PERFCTR_HLSQ_2_LO"/>
	<reg32 offset="0x00a7" name="RBBM_PERFCTR_HLSQ_2_HI"/>
	<reg32 offset="0x00a8" name="RBBM_PERFCTR_HLSQ_3_LO"/>
	<reg32 offset="0x00a9" name="RBBM_PERFCTR_HLSQ_3_HI"/>
	<reg32 offset="0x00aa" name="RBBM_PERFCTR_HLSQ_4_LO"/>
	<reg32 offset="0x00ab" name="RBBM_PERFCTR_HLSQ_4_HI"/>
	<reg32 offset="0x00ac" name="RBBM_PERFCTR_HLSQ_5_LO"/>
	<reg32 offset="0x00ad" name="RBBM_PERFCTR_HLSQ_5_HI"/>
	<reg32 offset="0x00ae" name="RBBM_PERFCTR_VPC_0_LO"/>
	<reg32 offset="0x00af" name="RBBM_PERFCTR_VPC_0_HI"/>
	<reg32 offset="0x00b0" name="RBBM_PERFCTR_VPC_1_LO"/>
	<reg32 offset="0x00b1" name="RBBM_PERFCTR_VPC_1_HI"/>
	<reg32 offset="0x00b2" name="RBBM_PERFCTR_TSE_0_LO"/>
	<reg32 offset="0x00b3" name="RBBM_PERFCTR_TSE_0_HI"/>
	<reg32 offset="0x00b4" name="RBBM_PERFCTR_TSE_1_LO"/>
	<reg32 offset="0x00b5" name="RBBM_PERFCTR_TSE_1_HI"/>
	<reg32 offset="0x00b6" name="RBBM_PERFCTR_RAS_0_LO"/>
	<reg32 offset="0x00b7" name="RBBM_PERFCTR_RAS_0_HI"/>
	<reg32 offset="0x00b8" name="RBBM_PERFCTR_RAS_1_LO"/>
	<reg32 offset="0x00b9" name="RBBM_PERFCTR_RAS_1_HI"/>
	<reg32 offset="0x00ba" name="RBBM_PERFCTR_UCHE_0_LO"/>
	<reg32 offset="0x00bb" name="RBBM_PERFCTR_UCHE_0_HI"/>
	<reg32 offset="0x00bc" name="RBBM_PERFCTR_UCHE_1_LO"/>
	<reg32 offset="0x00bd" name="RBBM_PERFCTR_UCHE_1_HI"/>
	<reg32 offset="0x00be" name="RBBM_PERFCTR_UCHE_2_LO"/>
	<reg32 offset="0x00bf" name="RBBM_PERFCTR_UCHE_2_HI"/>
	<reg32 offset="0x00c0" name="RBBM_PERFCTR_UCHE_3_LO"/>
	<reg32 offset="0x00c1" name="RBBM_PERFCTR_UCHE_3_HI"/>
	<reg32 offset="0x00c2" name="RBBM_PERFCTR_UCHE_4_LO"/>
	<reg32 offset="0x00c3" name="RBBM_PERFCTR_UCHE_4_HI"/>
	<reg32 offset="0x00c4" name="RBBM_PERFCTR_UCHE_5_LO"/>
	<reg32 offset="0x00c5" name="RBBM_PERFCTR_UCHE_5_HI"/>
	<reg32 offset="0x00c6" name="RBBM_PERFCTR_TP_0_LO"/>
	<reg32 offset="0x00c7" name="RBBM_PERFCTR_TP_0_HI"/>
	<reg32 offset="0x00c8" name="RBBM_PERFCTR_TP_1_LO"/>
	<reg32 offset="0x00c9" name="RBBM_PERFCTR_TP_1_HI"/>
	<reg32 offset="0x00ca" name="RBBM_PERFCTR_TP_2_LO"/>
	<reg32 offset="0x00cb" name="RBBM_PERFCTR_TP_2_HI"/>
	<reg32 offset="0x00cc" name="RBBM_PERFCTR_TP_3_LO"/>
	<reg32 offset="0x00cd" name="RBBM_PERFCTR_TP_3_HI"/>
	<reg32 offset="0x00ce" name="RBBM_PERFCTR_TP_4_LO"/>
	<reg32 offset="0x00cf" name="RBBM_PERFCTR_TP_4_HI"/>
	<reg32 offset="0x00d0" name="RBBM_PERFCTR_TP_5_LO"/>
	<reg32 offset="0x00d1" name="RBBM_PERFCTR_TP_5_HI"/>
	<reg32 offset="0x00d2" name="RBBM_PERFCTR_SP_0_LO"/>
	<reg32 offset="0x00d3" name="RBBM_PERFCTR_SP_0_HI"/>
	<reg32 offset="0x00d4" name="RBBM_PERFCTR_SP_1_LO"/>
	<reg32 offset="0x00d5" name="RBBM_PERFCTR_SP_1_HI"/>
	<reg32 offset="0x00d6" name="RBBM_PERFCTR_SP_2_LO"/>
	<reg32 offset="0x00d7" name="RBBM_PERFCTR_SP_2_HI"/>
	<reg32 offset="0x00d8" name="RBBM_PERFCTR_SP_3_LO"/>
	<reg32 offset="0x00d9" name="RBBM_PERFCTR_SP_3_HI"/>
	<reg32 offset="0x00da" name="RBBM_PERFCTR_SP_4_LO"/>
	<reg32 offset="0x00db" name="RBBM_PERFCTR_SP_4_HI"/>
	<reg32 offset="0x00dc" name="RBBM_PERFCTR_SP_5_LO"/>
	<reg32 offset="0x00dd" name="RBBM_PERFCTR_SP_5_HI"/>
	<reg32 offset="0x00de" name="RBBM_PERFCTR_SP_6_LO"/>
	<reg32 offset="0x00df" name="RBBM_PERFCTR_SP_6_HI"/>
	<reg32 offset="0x00e0" name="RBBM_PERFCTR_SP_7_LO"/>
	<reg32 offset="0x00e1" name="RBBM_PERFCTR_SP_7_HI"/>
	<reg32 offset="0x00e2" name="RBBM_PERFCTR_RB_0_LO"/>
	<reg32 offset="0x00e3" name="RBBM_PERFCTR_RB_0_HI"/>
	<reg32 offset="0x00e4" name="RBBM_PERFCTR_RB_1_LO"/>
	<reg32 offset="0x00e5" name="RBBM_PERFCTR_RB_1_HI"/>
	<reg32 offset="0x00ea" name="RBBM_PERFCTR_PWR_0_LO"/>
	<reg32 offset="0x00eb" name="RBBM_PERFCTR_PWR_0_HI"/>
	<reg32 offset="0x00ec" name="RBBM_PERFCTR_PWR_1_LO"/>
	<reg32 offset="0x00ed" name="RBBM_PERFCTR_PWR_1_HI"/>
	<reg32 offset="0x0100" name="RBBM_RBBM_CTL"/>
	<reg32 offset="0x0111" name="RBBM_DEBUG_BUS_CTL"/>
	<reg32 offset="0x0112" name="RBBM_DEBUG_BUS_DATA_STATUS"/>

	<!-- CP registers -->
	<reg32 offset="0x01c9" name="CP_PFP_UCODE_ADDR"/>
	<reg32 offset="0x01ca" name="CP_PFP_UCODE_DATA"/>
	<reg32 offset="0x01cc" name="CP_ROQ_ADDR"/>
	<reg32 offset="0x01cd" name="CP_ROQ_DATA"/>
	<reg32 offset="0x01d1" name="CP_MERCIU_ADDR"/>
	<reg32 offset="0x01d2" name="CP_MERCIU_DATA"/>
	<reg32 offset="0x01d3" name="CP_MERCIU_DATA2"/>
	<reg32 offset="0x01da" name="CP_MEQ_ADDR"/>
	<reg32 offset="0x01db" name="CP_MEQ_DATA"/>
	<reg32 offset="0x0445" name="CP_PERFCOUNTER_SELECT"/>
	<reg32 offset="0x045c" name="CP_HW_FAULT"/>
	<reg32 offset="0x045e" name="CP_PROTECT_CTRL"/>
	<reg32 offset="0x045f" name="CP_PROTECT_STATUS"/>
	<array offset="0x0460" name="CP_PROTECT" stride="1" length="16">
		<reg32 offset="0x0" name="REG"/>
	</array>
	<reg32 offset="0x054d" name="CP_AHB_FAULT"/>

	<!-- GRAS registers -->
	<reg32 offset="0x2040" name="GRAS_CL_CLIP_CNTL">
		<bitfield name="IJ_PERSP_CENTER" pos="12" type="boolean"/> <!-- is it more bits? -->
		<bitfield name="CLIP_DISABLE" pos="16" type="boolean"/>
		<bitfield name="ZFAR_CLIP_DISABLE" pos="17" type="boolean"/>
		<bitfield name="VP_CLIP_CODE_IGNORE" pos="19" type="boolean"/>
		<bitfield name="VP_XFORM_DISABLE" pos="20" type="boolean"/>
		<bitfield name="PERSP_DIVISION_DISABLE" pos="21" type="boolean"/>
	</reg32>
	<reg32 offset="0x2044" name="GRAS_CL_GB_CLIP_ADJ">
		<bitfield name="HORZ" low="0" high="9" type="uint"/>
		<bitfield name="VERT" low="10" high="19" type="uint"/>
	</reg32>
	<reg32 offset="0x2048" name="GRAS_CL_VPORT_XOFFSET" type="float"/>
	<reg32 offset="0x2049" name="GRAS_CL_VPORT_XSCALE" type="float"/>
	<reg32 offset="0x204a" name="GRAS_CL_VPORT_YOFFSET" type="float"/>
	<reg32 offset="0x204b" name="GRAS_CL_VPORT_YSCALE" type="float"/>
	<reg32 offset="0x204c" name="GRAS_CL_VPORT_ZOFFSET" type="float"/>
	<reg32 offset="0x204d" name="GRAS_CL_VPORT_ZSCALE" type="float"/>
	<reg32 offset="0x2068" name="GRAS_SU_POINT_MINMAX"/>
	<reg32 offset="0x2069" name="GRAS_SU_POINT_SIZE"/>
	<reg32 offset="0x206c" name="GRAS_SU_POLY_OFFSET_SCALE">
		<bitfield name="VAL" low="0" high="23" type="fixed" radix="20"/>
		<doc>range of -8.0 to 8.0</doc>
	</reg32>
	<reg32 offset="0x206d" name="GRAS_SU_POLY_OFFSET_OFFSET" radix="22" type="fixed">
		<doc>range of -512.0 to 512.0</doc>
	</reg32>
	<reg32 offset="0x2070" name="GRAS_SU_MODE_CONTROL">
		<bitfield name="CULL_FRONT" pos="0" type="boolean"/>
		<bitfield name="CULL_BACK" pos="1" type="boolean"/>
		<!-- guessing on size -->
		<bitfield name="LINEHALFWIDTH" low="2" high="10" type="uint"/>
		<bitfield name="POLY_OFFSET" pos="11" type="boolean"/>
	</reg32>
	<reg32 offset="0x2072" name="GRAS_SC_CONTROL">
		<!-- complete wild-ass-guess for sizes of these bitfields.. -->
		<bitfield name="RENDER_MODE" low="4" high="7" type="a3xx_render_mode"/>
		<bitfield name="MSAA_SAMPLES" low="8" high="11" type="a3xx_msaa_samples"/>
		<bitfield name="RASTER_MODE" low="12" high="15"/>
	</reg32>

	<bitset name="a3xx_reg_xy" inline="yes">
		<bitfield name="WINDOW_OFFSET_DISABLE" pos="31" type="boolean"/>  <!-- I assume it is same as a2xx -->
		<bitfield name="X" low="0" high="14" type="uint"/>
		<bitfield name="Y" low="16" high="30" type="uint"/>
	</bitset>

	<reg32 offset="0x2074" name="GRAS_SC_SCREEN_SCISSOR_TL" type="a3xx_reg_xy"/>
	<reg32 offset="0x2075" name="GRAS_SC_SCREEN_SCISSOR_BR" type="a3xx_reg_xy"/>
	<reg32 offset="0x2079" name="GRAS_SC_WINDOW_SCISSOR_TL" type="a3xx_reg_xy"/>
	<reg32 offset="0x207a" name="GRAS_SC_WINDOW_SCISSOR_BR" type="a3xx_reg_xy"/>

	<!-- RB registers -->
	<reg32 offset="0x20c0" name="RB_MODE_CONTROL">
		<!-- guess on the # of bits here.. -->
		<bitfield name="GMEM_BYPASS" pos="7" type="boolean"/>
		<doc>
			RENDER_MODE is RB_RESOLVE_PASS for gmem->mem, otherwise RB_RENDER_PASS
		</doc>
		<bitfield name="RENDER_MODE" low="8" high="10" type="a3xx_render_mode"/>
		<bitfield name="MARB_CACHE_SPLIT_MODE" pos="15" type="boolean"/>
		<bitfield name="PACKER_TIMER_ENABLE" pos="16" type="boolean"/>
	</reg32>
	<reg32 offset="0x20c1" name="RB_RENDER_CONTROL">
		<bitfield name="BIN_WIDTH" low="4" high="11" shr="5" type="uint"/>
		<bitfield name="DISABLE_COLOR_PIPE" pos="12" type="boolean"/>
		<!--
			ENABLE_GMEM not set on mem2gmem..  so possibly it is actually
			controlling blend or readback from GMEM??
		 -->
		<bitfield name="ENABLE_GMEM" pos="13" type="boolean"/>
		<bitfield name="ALPHA_TEST_FUNC" low="24" high="26" type="adreno_compare_func"/>
	</reg32>
	<reg32 offset="0x20c2" name="RB_MSAA_CONTROL">
		<bitfield name="DISABLE" pos="10" type="boolean"/>
		<bitfield name="SAMPLES" low="12" high="15" type="a3xx_msaa_samples"/>
		<bitfield name="SAMPLE_MASK" low="16" high="31" type="hex"/>
	</reg32>
	<reg32 offset="0x20c3" name="UNKNOWN_20C3">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<array offset="0x20c4" name="RB_MRT" stride="4" length="4">
		<reg32 offset="0x0" name="CONTROL">
			<bitfield name="READ_DEST_ENABLE" pos="3" type="boolean"/>
			<!-- both these bits seem to get set when enabling GL_BLEND.. -->
			<bitfield name="BLEND" pos="4" type="boolean"/>
			<bitfield name="BLEND2" pos="5" type="boolean"/>
			<bitfield name="ROP_CODE" low="8" high="11" type="uint"/>
			<bitfield name="DITHER_MODE" low="12" high="13" type="adreno_rb_dither_mode"/>
			<bitfield name="COMPONENT_ENABLE" low="24" high="27" type="hex"/>
		</reg32>
		<reg32 offset="0x1" name="BUF_INFO">
			<bitfield name="COLOR_FORMAT" low="0" high="5" type="a3xx_color_fmt"/>
			<bitfield name="COLOR_TILE_MODE" low="6" high="7" type="a3xx_tile_mode"/>
			<bitfield name="COLOR_SWAP" low="10" high="11" type="a3xx_color_swap"/>
			<doc>
				Pitch (actually, appears to be pitch in bytes, so really is a stride)
				in GMEM, so pitch of the current tile.
			</doc>
			<bitfield name="COLOR_BUF_PITCH" low="17" high="31" shr="5" type="uint"/>
		</reg32>
		<reg32 offset="0x2" name="BUF_BASE">
			<!--
				XXX maybe this is offsets into GMEM.. we seem to get 0x20000
				when depth buffer is enabled.. not sure if that means on
				that the color buffer comes *after* the depth/stencil buffer
				or that there are some high bits in here that are the offset
				of the depth/stencil buffer like on a2xx
			 -->
			<bitfield name="COLOR_BUF_BASE" low="4" high="31" shr="5" type="hex"/>
		</reg32>
		<reg32 offset="0x3" name="BLEND_CONTROL">
			<bitfield name="RGB_SRC_FACTOR" low="0" high="4" type="adreno_rb_blend_factor"/>
			<bitfield name="RGB_BLEND_OPCODE" low="5" high="7" type="adreno_rb_blend_opcode"/>
			<bitfield name="RGB_DEST_FACTOR" low="8" high="12" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_SRC_FACTOR" low="16" high="20" type="adreno_rb_blend_factor"/>
			<bitfield name="ALPHA_BLEND_OPCODE" low="21" high="23" type="adreno_rb_blend_opcode"/>
			<bitfield name="ALPHA_DEST_FACTOR" low="24" high="28" type="adreno_rb_blend_factor"/>
			<bitfield name="CLAMP_ENABLE" pos="29" type="boolean"/>
		</reg32>
	</array>

	<reg32 offset="0x20e4" name="RB_BLEND_RED">
		<bitfield name="UINT" low="0" high="7" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20e5" name="RB_BLEND_GREEN">
		<bitfield name="UINT" low="0" high="7" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20e6" name="RB_BLEND_BLUE">
		<bitfield name="UINT" low="0" high="7" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>
	<reg32 offset="0x20e7" name="RB_BLEND_ALPHA">
		<bitfield name="UINT" low="0" high="7" type="hex"/>
		<bitfield name="FLOAT" low="16" high="31" type="float"/>
	</reg32>

	<reg32 offset="0x20e8" name="UNKNOWN_20E8">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x20e9" name="UNKNOWN_20E9">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x20ea" name="UNKNOWN_20EA">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x20eb" name="UNKNOWN_20EB">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<enum name="adreno_rb_copy_control_mode">
		<value name="RB_COPY_RESOLVE" value="1"/>
		<value name="RB_COPY_DEPTH_STENCIL" value="5"/>  <!-- not sure if this is part of MODE or another bitfield?? -->
	</enum>
	<reg32 offset="0x20ec" name="RB_COPY_CONTROL">
		<!-- not sure # of bits -->
		<bitfield name="MSAA_RESOLVE" low="0" high="1" type="a3xx_msaa_samples"/>
		<bitfield name="MODE" low="4" high="6" type="adreno_rb_copy_control_mode"/>
		<bitfield name="GMEM_BASE" low="10" high="31" shr="10" type="hex"/>
	</reg32>
	<reg32 offset="0x20ed" name="RB_COPY_DEST_BASE">
		<bitfield name="BASE" low="4" high="31" shr="5" type="hex"/>
	</reg32>
	<reg32 offset="0x20ee" name="RB_COPY_DEST_PITCH">
		<doc>actually, appears to be pitch in bytes, so really is a stride</doc>
		<!-- not actually sure about max pitch... -->
		<bitfield name="PITCH" low="0" high="31" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x20ef" name="RB_COPY_DEST_INFO">
		<bitfield name="TILE" low="0" high="1" type="a3xx_tile_mode"/>
		<bitfield name="FORMAT" low="2" high="7" type="a3xx_color_fmt"/>
		<bitfield name="SWAP" low="8" high="9" type="a3xx_color_swap"/>
		<bitfield name="COMPONENT_ENABLE" low="14" high="17" type="hex"/>
		<bitfield name="ENDIAN" low="18" high="20" type="adreno_rb_surface_endian"/>
	</reg32>
	<reg32 offset="0x2100" name="RB_DEPTH_CONTROL">
		<!--
			guessing that this matches a2xx with the stencil fields
			moved out into RB_STENCIL_CONTROL?
		 -->
		<bitfield name="Z_ENABLE" pos="1" type="boolean"/>
		<bitfield name="Z_WRITE_ENABLE" pos="2" type="boolean"/>
		<bitfield name="EARLY_Z_ENABLE" pos="3" type="boolean"/>
		<bitfield name="ZFUNC" low="4" high="6" type="adreno_compare_func"/>
		<bitfield name="BF_ENABLE" pos="7" type="boolean"/>
		<doc>Z_TEST_ENABLE bit is set for zfunc other than GL_ALWAYS or GL_NEVER</doc>
		<bitfield name="Z_TEST_ENABLE" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x2101" name="UNKNOWN_2101">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2102" name="RB_DEPTH_INFO">
		<bitfield name="DEPTH_FORMAT" pos="0" type="adreno_rb_depth_format"/>
		<doc>
			DEPTH_BASE is offset in GMEM to depth/stencil buffer, ie
			bin_w * bin_h / 1024 (possible rounded up to multiple of
			something??  ie. 39 becomes 40, 78 becomes 80.. 75 becomes
			80.. so maybe it needs to be multiple of 8??
		</doc>
		<bitfield name="DEPTH_BASE" low="11" high="31" shr="10" type="uint"/>
	</reg32>
	<reg32 offset="0x2103" name="RB_DEPTH_PITCH" shr="3" type="uint">
		<doc>pitch of depth/stencil buffer</doc>
	</reg32>
	<reg32 offset="0x2104" name="RB_STENCIL_CONTROL">
		<bitfield name="STENCIL_ENABLE" pos="0" type="boolean"/>
		<bitfield name="STENCIL_ENABLE_BF" pos="2" type="boolean"/>
		<bitfield name="FUNC" low="8" high="10" type="adreno_compare_func"/>
		<bitfield name="FAIL" low="11" high="13" type="adreno_stencil_op"/>
		<bitfield name="ZPASS" low="14" high="16" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL" low="17" high="19" type="adreno_stencil_op"/>
		<bitfield name="FUNC_BF" low="20" high="22" type="adreno_compare_func"/>
		<bitfield name="FAIL_BF" low="23" high="25" type="adreno_stencil_op"/>
		<bitfield name="ZPASS_BF" low="26" high="28" type="adreno_stencil_op"/>
		<bitfield name="ZFAIL_BF" low="29" high="31" type="adreno_stencil_op"/>
	</reg32>
	<reg32 offset="0x2105" name="UNKNOWN_2105">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2106" name="UNKNOWN_2106">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2107" name="UNKNOWN_2107">
		<doc>seems to be always set to 0x00000000</doc>
	</reg32>
	<reg32 offset="0x2108" name="RB_STENCILREFMASK" type="adreno_rb_stencilrefmask"/>
	<reg32 offset="0x2109" name="RB_STENCILREFMASK_BF" type="adreno_rb_stencilrefmask"/>
	<reg32 offset="0x210e" name="PA_SC_WINDOW_OFFSET">
		<doc>X/Y offset of current bin</doc>
		<bitfield name="X" low="0" high="15" type="uint"/>
		<bitfield name="Y" low="16" high="31" type="uint"/>
	</reg32>

	<!-- PC registers -->
	<reg32 offset="0x21e4" name="PC_VSTREAM_CONTROL"/>
	<reg32 offset="0x21ea" name="PC_VERTEX_REUSE_BLOCK_CNTL"/>
	<reg32 offset="0x21ec" name="PC_PRIM_VTX_CNTL">
		<doc>
			STRIDE_IN_VPC: ALIGN(next_outloc - 8, 4) / 4
			(but, in cases where you'd expect 1, the blob driver uses
			2, so possibly 0 (no varying) or minimum of 2)
		</doc>
		<bitfield name="STRIDE_IN_VPC" low="0" high="4" type="uint"/>
		<bitfield name="POLYMODE_FRONT_PTYPE" low="5" high="7" type="adreno_pa_su_sc_draw"/>
		<bitfield name="POLYMODE_BACK_PTYPE" low="8" high="10" type="adreno_pa_su_sc_draw"/>
		<bitfield name="PROVOKING_VTX_LAST" pos="25" type="boolean"/>
	</reg32>
	<reg32 offset="0x21ed" name="PC_RESTART_INDEX"/>

	<!-- HLSQ registers -->
	<bitset name="a3xx_hlsq_vs_fs_control_reg" inline="yes">
		<bitfield name="CONSTLENGTH" low="0" high="11" type="uint"/>
		<bitfield name="CONSTSTARTOFFSET" low="12" high="23" type="uint"/>
		<bitfield name="INSTRLENGTH" low="24" high="31" type="uint"/>
	</bitset>
	<bitset name="a3xx_hlsq_const_vs_fs_presv_range_reg" inline="yes">
		<!-- are these a3xx_regid?? -->
		<bitfield name="STARTENTRY" low="0" high="15"/>
		<bitfield name="ENDENTRY" low="16" high="31"/>
	</bitset>

	<reg32 offset="0x2200" name="HLSQ_CONTROL_0_REG">
		<bitfield name="FSTHREADSIZE" pos="4" type="a3xx_threadsize"/>
		<bitfield name="FSSUPERTHREADENABLE" pos="6" type="boolean"/>
		<bitfield name="SPSHADERRESTART" pos="9" type="boolean"/>
		<bitfield name="RESERVED2" pos="10" type="boolean"/>
		<bitfield name="CHUNKDISABLE" pos="26" type="boolean"/>
		<bitfield name="CONSTSWITCHMODE" pos="27" type="boolean"/>
		<bitfield name="LAZYUPDATEDISABLE" pos="28" type="boolean"/>
		<bitfield name="SPCONSTFULLUPDATE" pos="29" type="boolean"/>
		<bitfield name="TPFULLUPDATE" pos="30" type="boolean"/>
		<bitfield name="SINGLECONTEXT" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x2201" name="HLSQ_CONTROL_1_REG">
		<bitfield name="VSTHREADSIZE" pos="6" type="a3xx_threadsize"/>
		<bitfield name="VSSUPERTHREADENABLE" pos="8" type="boolean"/>
		<bitfield name="RESERVED1" pos="9" type="boolean"/>
	</reg32>
	<reg32 offset="0x2202" name="HLSQ_CONTROL_2_REG">
		<bitfield name="PRIMALLOCTHRESHOLD" low="26" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2203" name="HLSQ_CONTROL_3_REG"/>
	<reg32 offset="0x2204" name="HLSQ_VS_CONTROL_REG" type="a3xx_hlsq_vs_fs_control_reg"/>
	<reg32 offset="0x2205" name="HLSQ_FS_CONTROL_REG" type="a3xx_hlsq_vs_fs_control_reg"/>
	<reg32 offset="0x2206" name="HLSQ_CONST_VSPRESV_RANGE_REG" type="a3xx_hlsq_const_vs_fs_presv_range_reg"/>
	<reg32 offset="0x2207" name="HLSQ_CONST_FSPRESV_RANGE_REG" type="a3xx_hlsq_const_vs_fs_presv_range_reg"/>
	<reg32 offset="0x220a" name="HLSQ_CL_NDRANGE_0_REG"/>
	<reg32 offset="0x220b" name="HLSQ_CL_NDRANGE_1_REG"/>
	<reg32 offset="0x220c" name="HLSQ_CL_NDRANGE_2_REG"/>
	<reg32 offset="0x2211" name="HLSQ_CL_CONTROL_0_REG"/>
	<reg32 offset="0x2212" name="HLSQ_CL_CONTROL_1_REG"/>
	<reg32 offset="0x2214" name="HLSQ_CL_KERNEL_CONST_REG"/>
	<reg32 offset="0x2215" name="HLSQ_CL_KERNEL_GROUP_X_REG"/>
	<reg32 offset="0x2217" name="HLSQ_CL_KERNEL_GROUP_Z_REG"/>
	<reg32 offset="0x221a" name="HLSQ_CL_WG_OFFSET_REG"/>

	<!-- VFD registers -->
	<reg32 offset="0x2240" name="VFD_CONTROL_0">
		<doc>
			TOTALATTRTOVS is # of attributes to vertex shader, in register
			slots (ie. vec4+vec3 -> 7)
		</doc>
		<bitfield name="TOTALATTRTOVS" low="0" high="17" type="uint"/>
		<bitfield name="PACKETSIZE" low="18" high="21" type="uint"/>
		<doc>STRMDECINSTRCNT is # of VFD_DECODE_INSTR registers valid</doc>
		<bitfield name="STRMDECINSTRCNT" low="22" high="26" type="uint"/>
		<doc>STRMFETCHINSTRCNT is # of VFD_FETCH_INSTR registers valid</doc>
		<bitfield name="STRMFETCHINSTRCNT" low="27" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2241" name="VFD_CONTROL_1">
		<doc>MAXSTORAGE could be # of attributes/vbo's</doc>
		<bitfield name="MAXSTORAGE" low="0" high="15" type="uint"/>
		<!--
			always seem to be 252 except when entire register is zero'd,
			but in these cases it is overwritten with non-zero value
			before the next DRAW_INDX
		 -->
		<bitfield name="REGID4VTX" low="16" high="23" type="a3xx_regid"/>
		<bitfield name="REGID4INST" low="24" high="31" type="a3xx_regid"/>
	</reg32>
	<reg32 offset="0x2242" name="VFD_INDEX_MIN" type="uint"/>
	<reg32 offset="0x2243" name="VFD_INDEX_MAX" type="uint"/>
	<reg32 offset="0x2244" name="VFD_INSTANCEID_OFFSET" type="uint"/>
	<reg32 offset="0x2245" name="VFD_INDEX_OFFSET" type="uint"/>
	<array offset="0x2246" name="VFD_FETCH" stride="2" length="16">
		<reg32 offset="0x0" name="INSTR_0">
			<bitfield name="FETCHSIZE" low="0" high="6" type="uint"/>
			<bitfield name="BUFSTRIDE" low="7" high="16" type="uint"/>
			<bitfield name="SWITCHNEXT" pos="17" type="boolean"/>
			<bitfield name="INDEXCODE" low="18" high="23" type="uint"/>
			<bitfield name="STEPRATE" low="24" high="31" type="uint"/>
		</reg32>
		<reg32 offset="0x1" name="INSTR_1"/>
	</array>
	<array offset="0x2266" name="VFD_DECODE" stride="1" length="16">
		<reg32 offset="0x0" name="INSTR">
			<bitfield name="WRITEMASK" low="0" high="3" type="hex"/>
			<!-- not sure if this is a bit flag and another flag above it, or?? -->
			<bitfield name="CONSTFILL" pos="4" type="boolean"/>
			<bitfield name="FORMAT" low="6" high="11" type="a3xx_vtx_fmt"/>
			<bitfield name="REGID" low="12" high="19" type="a3xx_regid"/>
			<doc>SHIFTCNT appears to be size, ie. FLOAT_32_32_32 is 12, and BYTE_8 is 1</doc>
			<bitfield name="SHIFTCNT" low="24" high="28" type="uint"/>
			<bitfield name="LASTCOMPVALID" pos="29" type="boolean"/>
			<bitfield name="SWITCHNEXT" pos="30" type="boolean"/>
		</reg32>
	</array>
	<reg32 offset="0x227e" name="VFD_VS_THREADING_THRESHOLD">
		<bitfield name="REGID_THRESHOLD" low="0" high="3" type="uint"/>
		<!-- <bitfield name="RESERVED6" low="4" high="7" type="uint"/> -->
		<bitfield name="REGID_VTXCNT" low="8" high="15" type="a3xx_regid"/>
	</reg32>

	<!-- VPC registers -->
	<reg32 offset="0x2280" name="VPC_ATTR">
		<bitfield name="TOTALATTR" low="0" high="11" type="uint"/>
		<bitfield name="THRDASSIGN" low="12" high="27" type="uint"/>
		<bitfield name="LMSIZE" low="28" high="31" type="uint"/>
	</reg32>
	<reg32 offset="0x2281" name="VPC_PACK">
		<!-- these are always seem to be set to same as TOTALATTR -->
		<bitfield name="NUMFPNONPOSVAR" low="8" high="15" type="uint"/>
		<bitfield name="NUMNONPOSVSVAR" low="16" high="23" type="uint"/>
	</reg32>
	<!--
		interpolate or interrupt?  former makes sense, but kernel calls
		it both "VARRYING_INTERUPT_MODE_n (sic) and VARYING_INTERP_MODE_n
		(and few other misspell variations..)
	 -->
	<array offset="0x2282" name="VPC_VARYING_INTERP" stride="1" length="4">
		<reg32 offset="0x0" name="MODE"/>
	</array>
	<array offset="0x2286" name="VPC_VARYING_PS_REPL" stride="1" length="4">
		<reg32 offset="0x0" name="MODE"/>
	</array>
	<reg32 offset="0x228a" name="VPC_VARY_CYLWRAP_ENABLE_0"/>
	<reg32 offset="0x228b" name="VPC_VARY_CYLWRAP_ENABLE_1"/>

	<!-- SP registers -->
	<bitset name="a3xx_vs_fs_length_reg" inline="yes">
		<bitfield name="SHADERLENGTH" low="0" high="31" type="uint"/>
	</bitset>
	<bitset name="a3xx_sp_vs_fs_ctrl_reg0" inline="yes">
		<!--
			NOTE that SP_{VS,FS}_CTRL_REG1 are different, but so far REG0
			appears to be the same..
		-->
		<bitfield name="THREADMODE" pos="0" type="a3xx_threadmode"/>
		<bitfield name="INSTRBUFFERMODE" pos="1" type="a3xx_instrbuffermode"/>
		<!-- maybe CACHEINVALID is two bits?? -->
		<bitfield name="CACHEINVALID" pos="2" type="boolean"/>
		<doc>
			The full/half register footprint is in units of four components,
			so if r0.x is used, that counts as all of r0.[xyzw] as used.
			There are separate full/half register footprint values as the
			full and half registers are independent (not overlapping).
			Presumably the thread scheduler hardware allocates the full/half
			register names from the actual physical register file and
			handles the register renaming.
		</doc>
		<bitfield name="HALFREGFOOTPRINT" low="4" high="9" type="uint"/>
		<bitfield name="FULLREGFOOTPRINT" low="10" high="17" type="uint"/>
		<!-- maybe INOUTREGOVERLAP is a bitflag? -->
		<bitfield name="INOUTREGOVERLAP" low="18" high="19" type="uint"/>
		<bitfield name="THREADSIZE" pos="20" type="a3xx_threadsize"/>
		<bitfield name="SUPERTHREADMODE" pos="21" type="boolean"/>
		<bitfield name="PIXLODENABLE" pos="22" type="boolean"/>
		<doc>
			From regspec:
			SP_FS_CTRL_REG0.FS_LENGTH [31:24]: FS length, unit = 256bits.
			If bit31 is 1, it means overflow
			or any long shader.
		</doc>
		<bitfield name="LENGTH" low="24" high="31" type="uint"/>
	</bitset>
	<bitset name="sp_vs_fs_obj_offset_reg" inline="yes">
		<doc>
			From register spec:
			SP_FS_OBJ_OFFSET_REG.CONSTOBJECTSTARTOFFSET [16:24]: Constant object
			start offset in on chip RAM,
			128bit aligned
		</doc>
		<bitfield name="CONSTOBJECTOFFSET" low="16" high="24" type="uint"/>
		<bitfield name="SHADEROBJOFFSET" low="25" high="31" type="uint"/>
	</bitset>

	<reg32 offset="0x22c0" name="SP_SP_CTRL_REG">
		<!-- this bit is set during resolve pass: -->
		<bitfield name="RESOLVE" pos="16" type="boolean"/>
		<!--
			guessing that these are two bits each.. but possibly could
			be just a flag with some other flags in between..
		-->
		<bitfield name="CONSTMODE" low="18" high="19" type="uint"/>
		<bitfield name="SLEEPMODE" low="20" high="21" type="uint"/>
		<!-- LOMODE==1 when oxiliForceSpL0ModeBuffer=1 -->
		<bitfield name="LOMODE" low="22" high="23" type="uint"/>
	</reg32>
	<reg32 offset="0x22c4" name="SP_VS_CTRL_REG0" type="a3xx_sp_vs_fs_ctrl_reg0"/>
	<reg32 offset="0x22c5" name="SP_VS_CTRL_REG1">
		<bitfield name="CONSTLENGTH" low="0" high="9" type="uint"/>
		<!--
			not sure about full vs half const.. I can't get blob generate
			something with a mediump/lowp uniform.
		 -->
		<bitfield name="CONSTFOOTPRINT" low="10" high="19" type="uint"/>
		<bitfield name="INITIALOUTSTANDING" low="24" high="29" type="uint"/>
	</reg32>
	<reg32 offset="0x22c6" name="SP_VS_PARAM_REG">
		<bitfield name="POSREGID" low="0" high="7" type="a3xx_regid"/>
		<bitfield name="PSIZEREGID" low="8" high="15" type="a3xx_regid"/>
		<bitfield name="TOTALVSOUTVAR" low="20" high="31" type="uint"/>
	</reg32>
	<array offset="0x22c7" name="SP_VS_OUT" stride="1" length="8">
		<reg32 offset="0x0" name="REG">
			<bitfield name="A_REGID" low="0" high="8" type="a3xx_regid"/>
			<bitfield name="A_COMPMASK" low="9" high="12" type="hex"/>
			<bitfield name="B_REGID" low="16" high="24" type="a3xx_regid"/>
			<bitfield name="B_COMPMASK" low="25" high="28" type="hex"/>
		</reg32>
	</array>
	<array offset="0x22d0" name="SP_VS_VPC_DST" stride="1" length="4">
		<reg32 offset="0x0" name="REG">
			<doc>
				These seem to be offsets for storage of the varyings.
				Always seems to start from 8, possibly loc 0 and 4
				are for gl_Position and gl_PointSize?
			</doc>
			<bitfield name="OUTLOC0" low="0" high="7" type="uint"/>
			<bitfield name="OUTLOC1" low="8" high="15" type="uint"/>
			<bitfield name="OUTLOC2" low="16" high="23" type="uint"/>
			<bitfield name="OUTLOC3" low="24" high="31" type="uint"/>
		</reg32>
	</array>
	<reg32 offset="0x22d4" name="SP_VS_OBJ_OFFSET_REG" type="sp_vs_fs_obj_offset_reg"/>
	<doc>
		SP_VS_OBJ_START_REG contains pointer to the vertex shader program,
		immediately followed by the binning shader program (although I
		guess that is probably just re-using the same gpu buffer)
	</doc>
	<reg32 offset="0x22d5" name="SP_VS_OBJ_START_REG"/>
	<!--
		SP_VS_PVT_MEM_CTRL_REG seems to always be 0x8000001 for gl.. and
		unused for opencl
	 -->
	<reg32 offset="0x22d6" name="SP_VS_PVT_MEM_CTRL_REG"/>
	<reg32 offset="0x22d7" name="SP_VS_PVT_MEM_ADDR_REG"/>
	<reg32 offset="0x22d8" name="SP_VS_PVT_MEM_SIZE_REG"/>
	<reg32 offset="0x22df" name="SP_VS_LENGTH_REG" type="a3xx_vs_fs_length_reg"/>
	<reg32 offset="0x22e0" name="SP_FS_CTRL_REG0" type="a3xx_sp_vs_fs_ctrl_reg0"/>
	<reg32 offset="0x22e1" name="SP_FS_CTRL_REG1">
		<bitfield name="CONSTLENGTH" low="0" high="9" type="uint"/>
		<bitfield name="CONSTFOOTPRINT" low="10" high="19" type="uint"/>
		<bitfield name="INITIALOUTSTANDING" low="20" high="23" type="uint"/>
		<!-- probably HALFPRECVAROFFSET goes to bit 31?? -->
		<bitfield name="HALFPRECVAROFFSET" low="24" high="29" type="uint"/>
	</reg32>
	<reg32 offset="0x22e2" name="SP_FS_OBJ_OFFSET_REG" type="sp_vs_fs_obj_offset_reg"/>
	<doc>SP_FS_OBJ_START_REG contains pointer to fragment shader program</doc>
	<reg32 offset="0x22e3" name="SP_FS_OBJ_START_REG"/>
	<!--
		SP_FS_PVT_MEM_CTRL_REG seems to always be 0x8000001 for gl..  so
		probably only matters for opencl
	 -->
	<reg32 offset="0x22e4" name="SP_FS_PVT_MEM_CTRL_REG"/>
	<reg32 offset="0x22e5" name="SP_FS_PVT_MEM_ADDR_REG"/>
	<reg32 offset="0x22e6" name="SP_FS_PVT_MEM_SIZE_REG"/>
	<reg32 offset="0x22e8" name="SP_FS_FLAT_SHAD_MODE_REG_0"/>
	<reg32 offset="0x22e9" name="SP_FS_FLAT_SHAD_MODE_REG_1"/>
	<reg32 offset="0x22ec" name="SP_FS_OUTPUT_REG"/>
	<array offset="0x22f0" name="SP_FS_MRT" stride="1" length="4">
		<reg32 offset="0x0" name="REG">
			<bitfield name="REGID" low="0" high="7" type="a3xx_regid"/>
			<bitfield name="HALF_PRECISION" pos="8" type="boolean"/>
		</reg32>
	</array>
	<array offset="0x22f4" name="SP_FS_IMAGE_OUTPUT" stride="1" length="4">
		<reg32 offset="0x0" name="REG">
			<bitfield name="MRTFORMAT" low="0" high="5" type="a3xx_color_fmt"/>
		</reg32>
	</array>
	<reg32 offset="0x22ff" name="SP_FS_LENGTH_REG" type="a3xx_vs_fs_length_reg"/>

	<!-- TPL1 registers -->
	<!-- assume VS/FS_TEX_OFFSET is same -->
	<bitset name="a3xx_tpl1_tp_vs_fs_tex_offset" inline="yes">
		<bitfield name="SAMPLEROFFSET" low="0" high="7" type="uint"/>
		<bitfield name="MEMOBJOFFSET" low="8" high="15" type="uint"/>
		<!-- not sure the size of this: -->
		<bitfield name="BASETABLEPTR" low="16" high="31" type="uint"/>
	</bitset>
	<reg32 offset="0x2340" name="TPL1_TP_VS_TEX_OFFSET" type="a3xx_tpl1_tp_vs_fs_tex_offset"/>
	<reg32 offset="0x2341" name="TPL1_TP_VS_BORDER_COLOR_BASE_ADDR"/>
	<reg32 offset="0x2342" name="TPL1_TP_FS_TEX_OFFSET" type="a3xx_tpl1_tp_vs_fs_tex_offset"/>
	<reg32 offset="0x2343" name="TPL1_TP_FS_BORDER_COLOR_BASE_ADDR"/>

	<!-- VBIF registers -->
	<reg32 offset="0x3001" name="VBIF_CLKON"/>
	<reg32 offset="0x300c" name="VBIF_FIXED_SORT_EN"/>
	<reg32 offset="0x300d" name="VBIF_FIXED_SORT_SEL0"/>
	<reg32 offset="0x300e" name="VBIF_FIXED_SORT_SEL1"/>
	<reg32 offset="0x301c" name="VBIF_ABIT_SORT"/>
	<reg32 offset="0x301d" name="VBIF_ABIT_SORT_CONF"/>
	<reg32 offset="0x302a" name="VBIF_GATE_OFF_WRREQ_EN"/>
	<reg32 offset="0x302c" name="VBIF_IN_RD_LIM_CONF0"/>
	<reg32 offset="0x302d" name="VBIF_IN_RD_LIM_CONF1"/>
	<reg32 offset="0x3030" name="VBIF_IN_WR_LIM_CONF0"/>
	<reg32 offset="0x3031" name="VBIF_IN_WR_LIM_CONF1"/>
	<reg32 offset="0x3034" name="VBIF_OUT_RD_LIM_CONF0"/>
	<reg32 offset="0x3035" name="VBIF_OUT_WR_LIM_CONF0"/>
	<reg32 offset="0x3036" name="VBIF_DDR_OUT_MAX_BURST"/>
	<reg32 offset="0x303c" name="VBIF_ARB_CTL"/>
	<reg32 offset="0x3049" name="VBIF_ROUND_ROBIN_QOS_ARB"/>
	<reg32 offset="0x3058" name="VBIF_OUT_AXI_AMEMTYPE_CONF0"/>
	<reg32 offset="0x305e" name="VBIF_OUT_AXI_AOOO_EN"/>
	<reg32 offset="0x305f" name="VBIF_OUT_AXI_AOOO"/>



	<reg32 offset="0x0c01" name="VSC_BIN_SIZE">
		<bitfield name="WIDTH" low="0" high="4" shr="5" type="uint"/>
		<bitfield name="HEIGHT" low="5" high="9" shr="5" type="uint"/>
	</reg32>
	<reg32 offset="0x0c02" name="VSC_SIZE_ADDRESS"/>
	<array offset="0x0c06" name="VSC_PIPE" stride="3" length="8">
		<reg32 offset="0x0" name="CONFIG">
			<doc>
				Configures the mapping between VSC_PIPE buffer and
				bin, X/Y specify the bin index in the horiz/vert
				direction (0,0 is upper left, 0,1 is leftmost bin
				on second row, and so on).  W/H specify the number
				of bins assigned to this VSC_PIPE in the horiz/vert
				dimension.
			</doc>
			<bitfield name="X" low="0" high="9" type="uint"/>
			<bitfield name="Y" low="10" high="19" type="uint"/>
			<bitfield name="W" low="20" high="23" type="uint"/>
			<bitfield name="H" low="24" high="27" type="uint"/>
		</reg32>
		<reg32 offset="0x1" name="DATA_ADDRESS"/>
		<reg32 offset="0x2" name="DATA_LENGTH"/>
	</array>
	<reg32 offset="0x0c3d" name="UNKNOWN_0C3D">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<reg32 offset="0x0c48" name="PC_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0c49" name="PC_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0c4a" name="PC_PERFCOUNTER2_SELECT"/>
	<reg32 offset="0x0c4b" name="PC_PERFCOUNTER3_SELECT"/>
	<reg32 offset="0x0c81" name="UNKNOWN_0C81">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<reg32 offset="0x0c88" name="GRAS_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0c89" name="GRAS_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0c8a" name="GRAS_PERFCOUNTER2_SELECT"/>
	<reg32 offset="0x0c8b" name="GRAS_PERFCOUNTER3_SELECT"/>
	<array offset="0x0ca0" name="GRAS_CL_USER_PLANE" stride="4" length="6">
		<reg32 offset="0x0" name="X"/>
		<reg32 offset="0x1" name="Y"/>
		<reg32 offset="0x2" name="Z"/>
		<reg32 offset="0x3" name="W"/>
	</array>
	<reg32 offset="0x0cc0" name="RB_GMEM_BASE_ADDR"/>
	<reg32 offset="0x0cc6" name="RB_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0cc7" name="RB_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0ce0" name="RB_WINDOW_SIZE">
		<bitfield name="WIDTH" low="0" high="13" type="uint"/>
		<bitfield name="HEIGHT" low="14" high="27" type="uint"/>
	</reg32>
	<reg32 offset="0x0e00" name="HLSQ_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0e01" name="HLSQ_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0e02" name="HLSQ_PERFCOUNTER2_SELECT"/>
	<reg32 offset="0x0e03" name="HLSQ_PERFCOUNTER3_SELECT"/>
	<reg32 offset="0x0e04" name="HLSQ_PERFCOUNTER4_SELECT"/>
	<reg32 offset="0x0e05" name="HLSQ_PERFCOUNTER5_SELECT"/>
	<reg32 offset="0x0e43" name="UNKNOWN_0E43">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<reg32 offset="0x0e44" name="VFD_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0e45" name="VFD_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0e61" name="VPC_VPC_DEBUG_RAM_SEL"/>
	<reg32 offset="0x0e62" name="VPC_VPC_DEBUG_RAM_READ"/>
	<reg32 offset="0x0e64" name="VPC_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0e65" name="VPC_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0e82" name="UCHE_CACHE_MODE_CONTROL_REG"/>
	<reg32 offset="0x0e84" name="UCHE_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0e85" name="UCHE_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0e86" name="UCHE_PERFCOUNTER2_SELECT"/>
	<reg32 offset="0x0e87" name="UCHE_PERFCOUNTER3_SELECT"/>
	<reg32 offset="0x0e88" name="UCHE_PERFCOUNTER4_SELECT"/>
	<reg32 offset="0x0e89" name="UCHE_PERFCOUNTER5_SELECT"/>
	<reg32 offset="0x0ea0" name="UCHE_CACHE_INVALIDATE0_REG">
		<!-- might be shifted right by 5, assuming 32byte cache line size.. -->
		<bitfield name="ADDR" low="0" high="27" type="hex"/>
	</reg32>
	<reg32 offset="0x0ea1" name="UCHE_CACHE_INVALIDATE1_REG">
		<!-- might be shifted right by 5, assuming 32byte cache line size.. -->
		<bitfield name="ADDR" low="0" high="27" type="hex"/>
		<!-- I'd assume 2 bits, for FLUSH/INVALIDATE/CLEAN? -->
		<bitfield name="OPCODE" low="28" high="29" type="a3xx_cache_opcode"/>
		<bitfield name="ENTIRE_CACHE" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="0x0ec4" name="SP_PERFCOUNTER0_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ec5" name="SP_PERFCOUNTER1_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ec6" name="SP_PERFCOUNTER2_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ec7" name="SP_PERFCOUNTER3_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ec8" name="SP_PERFCOUNTER4_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ec9" name="SP_PERFCOUNTER5_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0eca" name="SP_PERFCOUNTER6_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ecb" name="SP_PERFCOUNTER7_SELECT" type="a3xx_sp_perfcounter_select"/>
	<reg32 offset="0x0ee0" name="UNKNOWN_0EE0">
		<doc>seems to be always set to 0x00000003</doc>
	</reg32>
	<reg32 offset="0x0f03" name="UNKNOWN_0F03">
		<doc>seems to be always set to 0x00000001</doc>
	</reg32>
	<reg32 offset="0x0f04" name="TP_PERFCOUNTER0_SELECT"/>
	<reg32 offset="0x0f05" name="TP_PERFCOUNTER1_SELECT"/>
	<reg32 offset="0x0f06" name="TP_PERFCOUNTER2_SELECT"/>
	<reg32 offset="0x0f07" name="TP_PERFCOUNTER3_SELECT"/>
	<reg32 offset="0x0f08" name="TP_PERFCOUNTER4_SELECT"/>
	<reg32 offset="0x0f09" name="TP_PERFCOUNTER5_SELECT"/>
</domain>

<domain name="A3XX_TEX_SAMP" width="32">
	<doc>Texture sampler dwords</doc>
	<enum name="a3xx_tex_filter">
		<value name="A3XX_TEX_NEAREST" value="0"/>
		<value name="A3XX_TEX_LINEAR" value="1"/>
	</enum>
	<enum name="a3xx_tex_clamp">
		<value name="A3XX_TEX_REPEAT" value="0"/>
		<value name="A3XX_TEX_CLAMP_TO_EDGE" value="1"/>
		<value name="A3XX_TEX_MIRROR_REPEAT" value="2"/>
		<value name="A3XX_TEX_CLAMP_NONE" value="3"/>
	</enum>
	<reg32 offset="0" name="0">
		<bitfield name="MIPFILTER_LINEAR" pos="1" type="boolean"/>
		<bitfield name="XY_MAG" low="2" high="3" type="a3xx_tex_filter"/>
		<bitfield name="XY_MIN" low="4" high="5" type="a3xx_tex_filter"/>
		<bitfield name="WRAP_S" low="6" high="8" type="a3xx_tex_clamp"/>
		<bitfield name="WRAP_T" low="9" high="11" type="a3xx_tex_clamp"/>
		<bitfield name="WRAP_R" low="12" high="14" type="a3xx_tex_clamp"/>
		<!-- UNNORM_COORDS == CLK_NORMALIZED_COORDS_FALSE -->
		<bitfield name="UNNORM_COORDS" pos="31" type="boolean"/>
	</reg32>
	<reg32 offset="1" name="1"/>
</domain>

<domain name="A3XX_TEX_CONST" width="32">
	<doc>Texture constant dwords</doc>
	<enum name="a3xx_tex_swiz">
		<!-- same as a2xx? -->
		<value name="A3XX_TEX_X" value="0"/>
		<value name="A3XX_TEX_Y" value="1"/>
		<value name="A3XX_TEX_Z" value="2"/>
		<value name="A3XX_TEX_W" value="3"/>
		<value name="A3XX_TEX_ZERO" value="4"/>
		<value name="A3XX_TEX_ONE" value="5"/>
	</enum>
	<enum name="a3xx_tex_type">
		<value name="A3XX_TEX_1D" value="0"/>
		<value name="A3XX_TEX_2D" value="1"/>
		<value name="A3XX_TEX_CUBE" value="2"/>
		<value name="A3XX_TEX_3D" value="3"/>
	</enum>
	<reg32 offset="0" name="0">
		<bitfield name="TILED" pos="0" type="boolean"/>
		<bitfield name="SWIZ_X" low="4" high="6" type="a3xx_tex_swiz"/>
		<bitfield name="SWIZ_Y" low="7" high="9" type="a3xx_tex_swiz"/>
		<bitfield name="SWIZ_Z" low="10" high="12" type="a3xx_tex_swiz"/>
		<bitfield name="SWIZ_W" low="13" high="15" type="a3xx_tex_swiz"/>
		<bitfield name="MIPLVLS" low="16" high="19" type="uint"/>
		<bitfield name="FMT" low="22" high="28" type="a3xx_tex_fmt"/>
		<bitfield name="TYPE" low="30" high="31" type="a3xx_tex_type"/>
	</reg32>
	<reg32 offset="1" name="1">
		<bitfield name="HEIGHT" low="0" high="13" type="uint"/>
		<bitfield name="WIDTH" low="14" high="27" type="uint"/>
		<bitfield name="FETCHSIZE" low="28" high="31" type="a3xx_tex_fetchsize"/>
	</reg32>
	<reg32 offset="2" name="2">
		<doc>INDX is index of texture address(es) in MIPMAP state block</doc>
		<bitfield name="INDX" low="0" high="7" type="uint"/>
		<doc>Pitch in bytes (so actually stride)</doc>
		<bitfield name="PITCH" low="12" high="29" type="uint"/>
		<doc>SWAP bit is set for BGRA instead of RGBA</doc>
		<bitfield name="SWAP" low="30" high="31" type="a3xx_color_swap"/>
	</reg32>
	<reg32 offset="3" name="3"/>
</domain>

</database>
